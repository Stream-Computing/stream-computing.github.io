<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-希姆计算开发者资源/STCRP开发指南" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.9.1">
<title data-rh="true">STCRP开发指南 | 文档中心</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://your-docusaurus-site.example.com/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://your-docusaurus-site.example.com/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://your-docusaurus-site.example.com/docs/希姆计算开发者资源/STCRP开发指南"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="STCRP开发指南 | 文档中心"><meta data-rh="true" name="description" content="HPE异构编程指南"><meta data-rh="true" property="og:description" content="HPE异构编程指南"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://your-docusaurus-site.example.com/docs/希姆计算开发者资源/STCRP开发指南"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/docs/希姆计算开发者资源/STCRP开发指南" hreflang="en"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/docs/希姆计算开发者资源/STCRP开发指南" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"STCRP开发指南","item":"https://your-docusaurus-site.example.com/docs/希姆计算开发者资源/STCRP开发指南"}]}</script><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="文档中心 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="文档中心 Atom Feed"><link rel="stylesheet" href="/assets/css/styles.59b7a052.css">
<script src="/assets/js/runtime~main.462312d6.js" defer="defer"></script>
<script src="/assets/js/main.3e5567e0.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",t||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")),document.documentElement.setAttribute("data-theme-choice",t||"system")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/img/stc_logo.svg"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/stc_logo.svg" alt="" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/stc_logo.svg" alt="" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">STC DOCS HUB</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">文档</a><a class="navbar__item navbar__link" href="/blog">动态</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://www.streamcomputing.com/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">希姆计算<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro"><span title="Tutorial Intro" class="linkLabel_WmDU">Tutorial Intro</span></a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist" href="/docs/category/tutorial---basics"><span title="Tutorial - Basics" class="categoryLinkLabel_W154">Tutorial - Basics</span></a><button aria-label="Expand sidebar category &#x27;Tutorial - Basics&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist" href="/docs/category/tutorial---extras"><span title="Tutorial - Extras" class="categoryLinkLabel_W154">Tutorial - Extras</span></a><button aria-label="Expand sidebar category &#x27;Tutorial - Extras&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/希姆计算产品运维/k8s-device-plugin使用指南"><span title="希姆计算产品运维" class="categoryLinkLabel_W154">希姆计算产品运维</span></a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/希姆计算介绍"><span title="希姆计算" class="linkLabel_WmDU">希姆计算</span></a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" href="/docs/希姆计算开发者资源/C++ API"><span title="希姆计算开发者资源" class="categoryLinkLabel_W154">希姆计算开发者资源</span></a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/希姆计算开发者资源/C++ API"><span title="C++ API" class="linkLabel_WmDU">C++ API</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/希姆计算开发者资源/HPE错误信息分类标识"><span title="HPE错误信息分类标识" class="linkLabel_WmDU">HPE错误信息分类标识</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/希姆计算开发者资源/MLTC算子支持说明"><span title="MLTC算子支持说明" class="linkLabel_WmDU">MLTC算子支持说明</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/希姆计算开发者资源/Python API"><span title="Python API" class="linkLabel_WmDU">Python API</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/希姆计算开发者资源/STCRP开发指南"><span title="STCRP开发指南" class="linkLabel_WmDU">STCRP开发指南</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/希姆计算开发者资源/模型支持说明"><span title="模型支持说明" class="linkLabel_WmDU">模型支持说明</span></a></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/希姆计算术语表"><span title="希姆计算术语表" class="linkLabel_WmDU">希姆计算术语表</span></a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/希姆计算硬件产品/STCP920产品手册"><span title="希姆计算硬件产品" class="categoryLinkLabel_W154">希姆计算硬件产品</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/希姆计算解决方案/希姆算力云平台解决方案"><span title="希姆计算解决方案" class="categoryLinkLabel_W154">希姆计算解决方案</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/希姆计算软件产品/Firmware Release Notes"><span title="希姆计算软件产品" class="categoryLinkLabel_W154">希姆计算软件产品</span></a></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">希姆计算开发者资源</span></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">STCRP开发指南</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>STCRP开发指南</h1></header>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="hpe异构编程指南">HPE异构编程指南<a href="#hpe异构编程指南" class="hash-link" aria-label="Direct link to HPE异构编程指南" title="Direct link to HPE异构编程指南" translate="no">​</a></h2>
<p>HPE异构编程指南介绍了异构程序的编写方式。如需了解HPE监控调试工具的使用方法，请参见<a href="https://docs.streamcomputing.com/_/sharing/vSxLMI20nalGphdpXdEVoDg6JkUcfEkT?next=/zh/latest/" target="_blank" rel="noopener noreferrer">HPE使用指南</a>。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="异构编程模型">异构编程模型<a href="#异构编程模型" class="hash-link" aria-label="Direct link to 异构编程模型" title="Direct link to 异构编程模型" translate="no">​</a></h3>
<p>在异构编程环境中，设备端与主机端在计算和存储结构上存在差别，因此需要通过不同的方式执行函数和访问内存。异构编程模型中需要考虑核函数、内存管理、异步函数等因素。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="核函数">核函数<a href="#核函数" class="hash-link" aria-label="Direct link to 核函数" title="Direct link to 核函数" translate="no">​</a></h4>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="定义核函数">定义核函数<a href="#定义核函数" class="hash-link" aria-label="Direct link to 定义核函数" title="Direct link to 定义核函数" translate="no">​</a></h5>
<p>异构程序包括主机端程序和设备端程序，并引入核函数的概念来关联两类程序，核函数是两类代码的桥梁。核函数在主机端调用，由主机端部署到设备端，并在设备端的NPC上并行执行。</p>
<p>核函数使用<code>__global__</code>作为函数修饰符。在调用核函数时，需要通过<code>&lt;&lt;&lt; N &gt;&gt;&gt;</code>指定执行核函数时所用NPC的个数。<code>__global__</code>的详细用法，请参见<em>C++语言扩展接口</em>章节。</p>
<p>在下方的异构程序用例中，核函数的作用为打印hello word信息，然后在主机端指定8个NPC同时执行该核函数，执行结果为8个NPC分别输出一条hello word信息并在主机端显示。</p>
<blockquote>
<p>说明：异构程序的C++源文件以.hc作为扩展名。</p>
</blockquote>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;hpe.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;npurt.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">__global__ void kernel(void) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    printf(&quot;hello world in NPC %d/%d.\n&quot;, CoreID, CoreNum);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(void) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    kernel&lt;&lt;&lt;8&gt;&gt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcDeviceSynchronize();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="编译核函数">编译核函数<a href="#编译核函数" class="hash-link" aria-label="Direct link to 编译核函数" title="Direct link to 编译核函数" translate="no">​</a></h5>
<p>使用stcc统一编译异构程序，包括核函数。示例如下：</p>
<ul>
<li>
<p>编译单个源文件：编译hello_world.hc，输出名为hello_world的二进制文件。</p>
<div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ stcc hello_world.hc -o hello_world</span><br></span></code></pre></div></div>
</li>
<li>
<p>编译多个源文件：编译hello_world_1.hc和hello_world_2.hc，输出名为hello_world的二进制文件。</p>
<blockquote>
<p>说明：编译多个源文件时需要添加<code>--shc-combine-device</code>选项。</p>
</blockquote>
<div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ stcc hello_world_1.hc hello_world_2.hc --shc-combine-device -o hello_world</span><br></span></code></pre></div></div>
</li>
</ul>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="执行核函数">执行核函数<a href="#执行核函数" class="hash-link" aria-label="Direct link to 执行核函数" title="Direct link to 执行核函数" translate="no">​</a></h5>
<p>运行编译生成的二进制文件，在执行到核函数时，会自动转到设备端。</p>
<div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ ./hello_world</span><br></span></code></pre></div></div>
<p>默认在NPC Cluster 0上执行核函数，您也可以自行指定NPC Cluster。支持以下方式：</p>
<ul>
<li>通过环境变量STC_SET_DEVICES修改默认的起始NPC Cluster。例如<code>STC_SET_DEVICES</code>为3指定在NPC Cluster 3上执行核函数。</li>
<li>通过<code>stcSetDevice</code>单次指定NPC Cluster，<code>stcSetDevice</code>的效果为STC_SET_DEVICES基础上的增量。例如：<!-- -->
<ul>
<li><code>STC_SET_DEVICES</code>为0，则<code>stcSetDevice(1)</code>指定在NPC Cluster 1上执行核函数。</li>
<li><code>STC_SET_DEVICES</code>为2，则<code>stcSetDevice(1)</code>指定在NPC Cluster 3上执行核函数。</li>
</ul>
</li>
</ul>
<blockquote>
<p>说明：一个NPC Cluster只能同时运行一个核函数，即使在执行当前核函数时只使用了部分NPC，也不能在空闲的NPC上立即执行下一个核函数。</p>
</blockquote>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="内存管理">内存管理<a href="#内存管理" class="hash-link" aria-label="Direct link to 内存管理" title="Direct link to 内存管理" translate="no">​</a></h4>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="内存布局">内存布局<a href="#内存布局" class="hash-link" aria-label="Direct link to 内存布局" title="Direct link to 内存布局" translate="no">​</a></h5>
<p>希姆计算自研NPU中的内存分为本地内存（L1）、共享内存（LLB）、全局内存（DDR），各类型内存的大小和访问速度存在差别。</p>
<ul>
<li>全局内存：每个NPC Cluster私有的内存，由NPC Cluster内的NPC共享，访问速度最慢。STCP920芯片中，每个NPC Cluster的全局内存大小为4GiB。</li>
<li>共享内存：每个NPC Cluster私有的内存，由NPC Cluster内的NPC共享，访问速度较快。STCP920芯片中，每个NPC Cluster的共享内存大小为8MiB。</li>
<li>本地内存：每个NPC私有的内存，访问速度最快。STCP920芯片中，每个NPC的本地内存大小为1.25MiB。</li>
</ul>
<p>NPU中各NPC Cluster的内存布局完全相同，如下所示：</p>
<p><img decoding="async" loading="lazy" src="/assets/images/heterogeneous-programming-01-65deedbb2efaaaa488972ac14780e353.png" width="1189" height="643" class="img_ev3q"></p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="访问内存">访问内存<a href="#访问内存" class="hash-link" aria-label="Direct link to 访问内存" title="Direct link to 访问内存" translate="no">​</a></h5>
<p>在STCP920芯片中，每个NPC Cluster的4GiB全局内存分为以下类型：</p>
<ul>
<li>NPC可以直接访问的3GiB内存（0GiB ~ 3GiB）。</li>
<li>只能通过sysDMA访问的3GiB内存（3GiB+8M~3GiB+896M），也称为高端内存。</li>
</ul>
<p>主机端支持动态分配内存：</p>
<ul>
<li>在主机端调用<code>stcMalloc()</code>动态分配设备端全局内存（0GiB ~ 3GiB）。</li>
<li>在主机端调用<code>stcMallocHigh()</code>动态分配设备端全局内存（3GiB+8M~3GiB+896M）。</li>
</ul>
<p>设备端不支持动态分配内存，希姆计算提供了变量修饰符在指定的地址空间定义局部变量：</p>
<ul>
<li><code>__device__</code>：定义位于全局内存的局部变量和全局变量。如果定义局部变量时不添加变量修饰符，则默认位于全局内存。</li>
<li><code>__shared__</code>：定义位于共享内存的局部变量。</li>
<li><code>__local__</code>：定义位于本地内存的局部变量。</li>
</ul>
<blockquote>
<p>说明：本地内存（1.25MiB）、共享内存（8MiB）以及全局内存设备端运行栈（64KiB）的大小有限，请避免定义过大的局部变量。</p>
</blockquote>
<p>各类型内存支持的访问来源和访问方式的差别如下：</p>
<ul>
<li>支持从设备端访问本地内存、共享内存，支持从主机端和设备端访问全局内存。</li>
<li>在设备端调用<code>memcpy</code>读写设备端本地内存、共享内存、全局内存。</li>
<li>在主机端调用<code>stcMemcpy</code>、<code>stcMemcpyAsync</code>读写设备端全局内存。</li>
</ul>
<blockquote>
<p>说明：在设备端访问全局内存时（访问局部变量除外），请确保访问区域不会被其他NPC缓存。因为NPC的cache line大小为32字节，如果多个NPC访问同一个32字节地址对齐且大小不超过32字节的区域，NPC刷新缓存会导致无法保障全局内存中数据的正确性。</p>
</blockquote>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="访问内存用例">访问内存用例<a href="#访问内存用例" class="hash-link" aria-label="Direct link to 访问内存用例" title="Direct link to 访问内存用例" translate="no">​</a></h5>
<p>下方的用例中，在主机端分配全局内存并写入数据，然后在设备端使用8个NPC分别将全局内存中的数据拷贝到共享内存和本地内存，并打印拷贝结果。</p>
<blockquote>
<p>说明：各变量修饰符和接口的详细说明，请参见<em>变量修饰符</em>章节和<em>运行时接口</em>章节。</p>
</blockquote>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;hpe.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;npurt.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define NCORE 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">__global__ void kernel(int *global_data) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    __shared__ int shared_data[NCORE];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    __local__ int local_data[NCORE];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memcpy(shared_data, global_data, sizeof(shared_data));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memcpy(local_data, global_data, sizeof(local_data));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    printf(&quot;core %d read shared data %d local data %d\n&quot;, CoreID,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           shared_data[CoreID], local_data[CoreID]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(void) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int host_data[] = {1, 2, 3, 4, 5, 6, 7, 8};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int *dev_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcMalloc((void **)&amp;dev_data, sizeof(host_data));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcMemcpy(dev_data, host_data, sizeof(host_data), stcMemcpyHostToDevice);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    kernel&lt;&lt;&lt;NCORE&gt;&gt;&gt;(dev_data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcDeviceSynchronize();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcFree(dev_data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="异步函数">异步函数<a href="#异步函数" class="hash-link" aria-label="Direct link to 异步函数" title="Direct link to 异步函数" translate="no">​</a></h4>
<p>部分运行时接口的函数类型设计为异步函数，在主机端调用异步函数后会立即返回，不用等待完成异步函数规定的所有操作，有利于主机端和设备端并行处理任务。例如，调用<code>stcLaunchKernel</code>在主机端启动核函数后，主机端无需等待完成核函数的所有操作即可开始处理下一个任务；调用<code>stcMemcpyAsync</code>在主机端和设备端之间拷贝数据后，主机端无需等待拷贝完所有数据即可开始处理下一个任务。</p>
<p>异步函数的返回值不是异步操作的结果。如果您调用了异步函数，但仍然需要等待所有操作完成，可以调用<code>stcDeviceSynchronize</code>、<code>stcStreamSynchronize</code>或<code>stcStreamSynchronizeUnified</code>等待设备或流上的所有操作完成后再处理下一个任务。<code>stcDeviceSynchronize</code>、<code>stcStreamSynchronize</code>和<code>stcStreamSynchronizeUnified</code>的返回值是异步操作的结果，但仅返回最后一个异步操作的结果。</p>
<blockquote>
<p>说明：核函数没有返回值，如果核函数在真正开始执行前出错退出，只能通过<code>stcGetLastError</code>获取错误信息。例如指定的NPC数量超过实际的NPC数量，导致启动核函数后还未实际执行就出错退出。</p>
</blockquote>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="异构编程典型操作">异构编程典型操作<a href="#异构编程典型操作" class="hash-link" aria-label="Direct link to 异构编程典型操作" title="Direct link to 异构编程典型操作" translate="no">​</a></h3>
<p>希姆计算提供了丰富的运行时接口，方便您从主机端控制在设备端执行任务。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="指定运行设备">指定运行设备<a href="#指定运行设备" class="hash-link" aria-label="Direct link to 指定运行设备" title="Direct link to 指定运行设备" translate="no">​</a></h4>
<p>主机端访问设备端时需要指定运行设备。在主机端程序中启动核函数后，默认在NPC Cluster 0上执行核函数，您也可以提前通过调用<code>stcSetDevice</code>或修改STC_SET_DEVICES指定其他NPC Cluster。示例如下：</p>
<ol>
<li>
<p>推导NPC Cluster ID。</p>
<p>以STCP920芯片为例，执行<code>stc-smi -q</code>命令获取NPU的信息，包括NPU设备标识符、NPC Cluster设备标识符等。</p>
<p>代码中使用的NPC Cluster ID由NPU设备标识符、NPC Cluster设备标识符推导得出。假设需要指定一个NPC Cluster，查看得知其对应的NPU设备标识符为x、NPC Cluster设备标识符为y，则推导方式为NPC Cluster ID = 4 * x + y。例如，NPU设备标识符为为0，NPC Cluster设备标识符为1，则NPC Cluster ID为1。</p>
</li>
<li>
<p>在代码中调用<code>stcSetDevice</code>指定NPC Cluster ID。</p>
<p>下方的用例中，指定使用NPC Cluster 1，然后8个NPC分别输出一条hello word信息并在主机端显示。</p>
<blockquote>
<p>说明：一个进程中各个线程调用<code>stcSetDevice</code>互不影响，如果需要修改使用的NPC Cluster，请分别设置。</p>
</blockquote>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;hpe.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;npurt.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">__global__ void kernel(void) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    printf(&quot;hello world in NPC %d/%d.\n&quot;, CoreID, CoreNum);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(void) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcSetDevice(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    kernel&lt;&lt;&lt;8&gt;&gt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcDeviceSynchronize();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
</li>
</ol>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="访问设备端全局内存">访问设备端全局内存<a href="#访问设备端全局内存" class="hash-link" aria-label="Direct link to 访问设备端全局内存" title="Direct link to 访问设备端全局内存" translate="no">​</a></h4>
<p>访问设备端全局内存的运行时接口如下：</p>
<ul>
<li>在主机端调用<code>stcMalloc</code>动态分配设备端全局内存（0GiB ~ 3GiB）。</li>
<li>在主机端调用<code>stcMallocHigh</code>动态分配设备端全局内存（3GiB+8M~3GiB+896M）。</li>
<li>在主机端调用<code>stcMemcpy</code>、<code>stcMemcpyAsync</code>读写设备端全局内存。</li>
</ul>
<p>在STCP920芯片中，每个NPC Cluster的4GiB全局内存分为以下类型：</p>
<ul>
<li>NPC可以直接访问的3GiB内存（0GiB ~ 3GiB）。</li>
<li>只能通过sysDMA访问的1GiB内存（3GiB+8M~3GiB+896M），也称为高端内存。</li>
</ul>
<p>下方的用例中，分别在不同的内存范围中分配了内存：</p>
<ul>
<li>
<p>在主机端分配0GiB ~ 3GiB范围的全局内存并写入数据，然后在设备端打印数据。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;hpe.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;npurt.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">__global__ void kernel(int *data) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    printf(&quot;core %d read data %d\n&quot;, CoreID, data[CoreID]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(void) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int host_data[] = {1, 2, 3, 4, 5, 6, 7, 8};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int *dev_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcMalloc((void **)&amp;dev_data, sizeof(host_data));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcMemcpy(dev_data, host_data, sizeof(host_data), stcMemcpyHostToDevice);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    kernel&lt;&lt;&lt;8&gt;&gt;&gt;(dev_data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcDeviceSynchronize();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcFree(dev_data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
</li>
<li>
<p>在主机端分配3GiB+8M~3GiB+896M范围的全局内存并写入数据，然后在设备端将数据从高端内存拷贝到NPC可以直接访问的范围，并打印拷贝结果。</p>
<blockquote>
<p>说明：NPC不能直接访问高端内存，因此本用例中，核函数内的<code>memcpy</code>不能替换为<code>data = high[CoreID]</code>，否则会触发NPC读访问异常。</p>
</blockquote>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;npurt.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;hpe.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">__global__ void kernel(int *high) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        memcpy(&amp;data, &amp;high[CoreID], sizeof(data));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;core %d read data %d\n&quot;, CoreID, data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(void) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int host_data[] = {1, 2, 3, 4, 5, 6, 7, 8};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int *dev_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcMallocHigh((void **)&amp;dev_data, sizeof(host_data));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcMemcpy(dev_data, host_data, sizeof(host_data), stcMemcpyHostToDevice);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    kernel&lt;&lt;&lt;8&gt;&gt;&gt;(dev_data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcDeviceSynchronize();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcFree(dev_data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="并行执行">并行执行<a href="#并行执行" class="hash-link" aria-label="Direct link to 并行执行" title="Direct link to 并行执行" translate="no">​</a></h4>
<p>主机端发送给设备端的请求类型包括执行核函数（Kernel）、从主机端向设备端拷贝数据（H2D）、从设备端向主机端拷贝数据（D2H）。主机端可以并行发起不同类型的请求，但一个或多个NPC Cluster内是顺序处理请求的。希姆计算提供了流的运行时接口，您可以基于流实现一个或多个NPC Cluster内并行处理请求。</p>
<p>在异构编程环境中，流分为UnifiedHS模式的流和DividedHS模式的流。在DividedHS模式上流在一个Cluster上运行，每一个同步域中包含8个NPC。在UnifiedHS模式下可以将一个核函数放在多个NPC Cluster乃至多张板卡上运行，适用于需要更多NPC并行以及更大片上内存的场景，例如运行大模型。在UnifiedHS模式上流在四个Cluster上运行，每一个同步域中包含32个NPC。</p>
<blockquote>
<p>说明： UnifiedHS流上的核函数在执行时，因为其占用了所有32个NPC，所以其它普通流的核函数均无法被调度。</p>
</blockquote>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="流定义">流定义<a href="#流定义" class="hash-link" aria-label="Direct link to 流定义" title="Direct link to 流定义" translate="no">​</a></h5>
<p>流（stream）是由主机端发起、设备端处理的一系列请求。同一个流内的请求顺序处理，不同流间的不同类型请求可以并行处理。 流包括以下类型：</p>
<ul>
<li>隐式声明流：默认创建的流，只有一个，可以包括同步、异步请求。执行核函数、拷贝数据时默认使用隐式声明流。</li>
<li>显示声明流：您自行创建的流，只能包括异步请求。执行核函数、拷贝数据（异步）时可以使用显示声明流。</li>
</ul>
<blockquote>
<p>说明：在一个NPC Cluster上创建的DividedHS模式的流只能在该NPC Cluster上使用。</p>
</blockquote>
<p>下方的用例中，创建了一个显示声明流来执行核函数。如果需要等待流上的所有操作完成后再处理下一个请求，调用<code>stcStreamSynchronize</code>或<code>stcDeviceSynchronize</code>即可。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;npurt.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;hpe.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">__global__ void kernel(void) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    printf(&quot;hello world in NPC %d/%d.\n&quot;, CoreID, CoreNum);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(void) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcStream_t stream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcStreamCreate(&amp;stream);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    kernel&lt;&lt;&lt;8, stream&gt;&gt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcStreamSynchronize(stream);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcStreamDestroy(stream);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="流调度">流调度<a href="#流调度" class="hash-link" aria-label="Direct link to 流调度" title="Direct link to 流调度" translate="no">​</a></h5>
<p>同一流内的请求只能顺序调度，不同流间的不同类型请求可以并行调度。假定有三组请求，均包括H2D、Kernel、D2H请求，且不同组的请求之间没有依赖关系，采取并行调度可以提高性能。顺序调度和并行调度的性能对比如下：</p>
<p><img decoding="async" loading="lazy" src="/assets/images/heterogeneous-programming-02-12b999083a229391567eff8315c33952.png" width="1067" height="440" class="img_ev3q"></p>
<blockquote>
<p>说明：仅当所有cluster都空闲时才能执行UnifiedHS模式流中的kernel任务。在执行UnifiedHS模式下的kernel任务时，其它DividedHS流中的kernel任务不能被调度。</p>
</blockquote>
<p>顺序调度和并行调度的代码示例如下：</p>
<ul>
<li>
<p>顺序调度，顺序在NPC Cluster上处理每组请求。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;hpe.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;npurt.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">__global__ void kernel(int *in, int *out) { *out = *in; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define NJOB 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(void) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int host_in[NJOB] = {1, 2, 3};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int host_out[NJOB];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int *dev_in[NJOB], *dev_out[NJOB];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; NJOB; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        stcMalloc((void **)&amp;dev_in[i], sizeof(int));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        stcMalloc((void **)&amp;dev_out[i], sizeof(int));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; NJOB; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        stcMemcpyAsync(dev_in[i], &amp;host_in[i], sizeof(int),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       stcMemcpyHostToDevice);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        kernel&lt;&lt;&lt;1&gt;&gt;&gt;(dev_in[i], dev_out[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        stcMemcpyAsync(&amp;host_out[i], dev_out[i], sizeof(int),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       stcMemcpyDeviceToHost);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcDeviceSynchronize();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; NJOB; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;%d, &quot;, host_out[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        stcFree(dev_in[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        stcFree(dev_out[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    printf(&quot;\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
</li>
<li>
<p>并行调度，为每组请求创建一个显示声明流，并在NPC Cluster上并行处理三个流中的请求。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;hpe.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;npurt.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">__global__ void kernel(int *in, int *out) { *out = *in; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define NJOB 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(void) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int host_in[NJOB] = {1, 2, 3};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int host_out[NJOB];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int *dev_in[NJOB], *dev_out[NJOB];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcStream_t stream[NJOB];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; NJOB; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        stcMalloc((void **)&amp;dev_in[i], sizeof(int));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        stcMalloc((void **)&amp;dev_out[i], sizeof(int));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        stcStreamCreate(&amp;stream[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; NJOB; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        stcMemcpyAsync(dev_in[i], &amp;host_in[i], sizeof(int),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       stcMemcpyHostToDevice, stream[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        kernel&lt;&lt;&lt;1, stream[i]&gt;&gt;&gt;(dev_in[i], dev_out[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        stcMemcpyAsync(&amp;host_out[i], dev_out[i], sizeof(int),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       stcMemcpyDeviceToHost, stream[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcDeviceSynchronize();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; NJOB; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;%d, &quot;, host_out[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        stcFree(dev_in[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        stcFree(dev_out[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        stcStreamDestroy(stream[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    printf(&quot;\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
</li>
</ul>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="流同步">流同步<a href="#流同步" class="hash-link" aria-label="Direct link to 流同步" title="Direct link to 流同步" translate="no">​</a></h5>
<p>事件（event）用于在流中插入标记，当流中该标记前的请求处理完毕后，会将事件置为完成状态。事件具有以下用途：</p>
<ul>
<li>监控流的进展：调用<code>stcEventElapsedTime</code>获取处理两个事件间请求所消耗的时间。</li>
<li>同步流的执行：在多流场景中，如果不同流中的请求之间有依赖关系，可以调用<code>stcStreamWaitEvent</code>进行同步，在事件被置为完成状态后再开始处理其他流中的请求。</li>
</ul>
<p>下方的用例中，定义了两个核函数kernel1、kernel2，kernel1循环执行共20次，在kernel1执行10次后添加事件，触发执行1次kernel2。</p>
<blockquote>
<p>说明：调用<code>stcEventRecord</code>添加事件时，如果不指定流，则为所有流添加事件，在所有流中标记前的请求都处理完毕后，才会将事件置为完成状态。</p>
</blockquote>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;hpe.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;npurt.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">__global__ void kernel1(int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    printf(&quot;%s index %d come in\n&quot;, __func__, index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">__global__ void kernel2(void) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    printf(&quot;%s come in\n&quot;, __func__);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(void) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcStream_t stream1, stream2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcEvent_t event1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcStreamCreate(&amp;stream1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcStreamCreate(&amp;stream2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcEventCreate(&amp;event1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 1; i &lt;= 20; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        kernel1&lt;&lt;&lt;1, stream1&gt;&gt;&gt;(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (i == 10)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            stcEventRecord(event1, stream1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcStreamWaitEvent(stream2, event1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    kernel2&lt;&lt;&lt;1, stream2&gt;&gt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcDeviceSynchronize();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcStreamDestroy(stream1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcStreamDestroy(stream2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcEventDestroy(event1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="获取性能数据">获取性能数据<a href="#获取性能数据" class="hash-link" aria-label="Direct link to 获取性能数据" title="Direct link to 获取性能数据" translate="no">​</a></h4>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="使用流程示例">使用流程示例<a href="#使用流程示例" class="hash-link" aria-label="Direct link to 使用流程示例" title="Direct link to 使用流程示例" translate="no">​</a></h5>
<p>使用STCPTI分析目标异构程序性能的流程如下：</p>
<ol>
<li>
<p>在异构程序源代码中添加STCPTI性能数据采集代码。</p>
<ol>
<li>包含头文件stcpti.h。</li>
<li>定义用于记录性能数据的STCpti_PerfDatas结构体。</li>
<li>调用<code>stcptiKernelContextCreate</code>为当前进程创建核函数性能数据采集的上下文。</li>
<li>调用<code>stcptiKernelEnable</code>开始采集性能数据。</li>
<li>执行核函数。</li>
<li>调用<code>stcDeviceSynchronize</code>等待执行完成。</li>
<li>调用<code>stcptiKernelGetPerfDatas</code>获取核函数性能数据。</li>
<li>调用<code>stcptiKernelDisable</code>停止采集性能数据。</li>
<li>输出核函数性能数据。输出方法和STCpti_PerfDatas结构体的元素有关，详细的元素说明，请参见<em>数据类型</em>章节。</li>
<li>调用<code>stcptiKernelContextRelease</code>为当前进程释放核函数性能数据采集的上下文。</li>
</ol>
</li>
<li>
<p>编译添加了性能数据代码采集的异构程序，编译时需要添加链接选项<code>-lprofiler_stc</code>和<code>-ltracer_stc</code>。以在matrix-multiply.hc中添加STCPTI性能数据采集代码后的matrix-multiply-stcpti.hc为例：</p>
<div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ stcc --rtlib=compiler-rt matrix-multiply-stcpti.hc -DNCORE=8 -lprofiler_stc -ltracer_stc -o matrix-multiply-stcpti</span><br></span></code></pre></div></div>
</li>
<li>
<p>执行编译得到的二进制文件。</p>
<div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ ./matrix-multiply-stcpti</span><br></span></code></pre></div></div>
</li>
</ol>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="代码示例">代码示例<a href="#代码示例" class="hash-link" aria-label="Direct link to 代码示例" title="Direct link to 代码示例" translate="no">​</a></h5>
<p>添加了STCPTI性能数据采集代码后的matrix-multiply-stcpti.hc的完整示例代码如下：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Copyright (c) 2019-2021 北京希姆计算科技有限公司 (Stream Computing Inc.)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * All Rights Reserved.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * NOTICE: All intellectual and technical information contained herein</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * are proprietary to Stream Computing Inc. Any unauthorized disemination,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * copying or redistribution of this file via any medium is strictly prohibited,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * unless you get a prior written permission or an applicable license agreement</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * from Stream Computing Inc.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * This example uses internal instructions to do matrix multiply.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;asm_macro.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;hpe.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;npurt.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#if !defined(__SHC_NPU_COMPILE__)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;stcpti.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// number of left matrix&#x27;s col and right matrix&#x27;s row</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define LCOL_RROW 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// local_left * local_right = local_out</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">__device__ void matmul(__fp16 *local_out, __fp16 *local_left,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       __fp16 *local_right) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int shape1, shape2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // do matrix multiply and result must be stored in IM buffer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    shape1 = DEFINE_SHAPE(LCOL_RROW, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    shape2 = DEFINE_SHAPE(1, LCOL_RROW);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CONFIG_VE_BC_CSR(shape1, shape2, 0, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memul_mm((__fp16 *)IM_BUFFER_START, local_left, local_right);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // move result from IM buffer to local memory</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    shape1 = DEFINE_SHAPE(1, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    shape2 = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CONFIG_VE_CSR(shape1, shape2, 0, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mov_m(local_out, (__fp16 *)IM_BUFFER_START);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">__global__ void matmul_kernel(__fp16 *global_out, __fp16 *global_left,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              __fp16 *global_right) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    __local__ __fp16 local_left[LCOL_RROW];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    __local__ __fp16 local_right[LCOL_RROW];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    __local__ __fp16 local_out;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    __shared__ __fp16 share_out[CoreNum];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    printf(&quot;CoreNum is %d\n&quot;, CoreNum);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // copy right matrix to each core</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memcpy(local_right, global_right, LCOL_RROW * sizeof(__fp16));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // copy a row of left matrix for each core</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memcpy(local_left, global_left + CoreID * LCOL_RROW,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           LCOL_RROW * sizeof(__fp16));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // matrix multiply</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    matmul(&amp;local_out, local_left, local_right);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // copy result in local memory of each core to shared memory</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memcpy(share_out + CoreID, &amp;local_out, sizeof(__fp16));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // sync to wait each of the core compute share_out data filled</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sync();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (CoreID == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // copy result in share memory of each core to global memory</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        memcpy(global_out, share_out, CoreNum * sizeof(__fp16));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define NCORE 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(void) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    __fp16 *dev_left, *dev_right, *dev_out;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // define struct for recording performance data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    STCpti_PerfDatas perf_data = {0};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // enable stcpti</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcptiKernelContextCreate();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcptiKernelEnable();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // left matrix data for 8 cores</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    __fp16 host_left[8 * LCOL_RROW] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, // row1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, // row2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, // row3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, // row4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        4.0, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0, // row5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, // row6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        6.0, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0, // row7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        7.0, 7.0, 7.0, 7.0, 7.0, 7.0, 7.0, 7.0, // row8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // right matrix data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    __fp16 host_right[LCOL_RROW] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // copy left matrix to device</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int mat_size_left = NCORE * LCOL_RROW * sizeof(__fp16);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcMalloc((void **)&amp;dev_left, mat_size_left);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcMemcpy(dev_left, host_left, mat_size_left, stcMemcpyHostToDevice);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // copy right matrix to device</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int mat_size_right = LCOL_RROW * sizeof(__fp16);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcMalloc((void **)&amp;dev_right, mat_size_right);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcMemcpy(dev_right, host_right, mat_size_right, stcMemcpyHostToDevice);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // allocate result buffer in device</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int mat_size_out = NCORE * sizeof(__fp16);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    __fp16 host_out[NCORE];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcMalloc((void **)&amp;dev_out, mat_size_out);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    matmul_kernel&lt;&lt;&lt;NCORE&gt;&gt;&gt;(dev_out, dev_left, dev_right);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcDeviceSynchronize();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // copy result from device to host</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcMemcpy(host_out, dev_out, mat_size_out, stcMemcpyDeviceToHost);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    printf(&quot;matrix multiply result:&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; NCORE; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;%.1f, &quot;, (float)(host_out[i]));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    printf(&quot;\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // get performance data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcptiKernelGetPerfDatas(&amp;perf_data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcptiKernelDisable();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const char* name = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     for (int i = 0; i &lt; perf_data.kernelPerfDataSize; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        STCpti_KernelPerfDatas *kernel_perf_datas_ptr =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &amp;perf_data.pKernelPerfDatas[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int j = 0; j &lt; kernel_perf_datas_ptr-&gt;kernelNpcPerfDataSize; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            STCpti_KernelNpcPerfData *kernel_npc_perf_data_ptr =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &amp;kernel_perf_datas_ptr-&gt;arrKernelNpcPerfData[j];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int m = 0; m &lt; STC_PTI_EVENT_ID_SYSDMA0_DMA_ID; m++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                stcptiGetEventNameFromID(m, &amp;name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;kernel: %d npc: %d event %02d %s [%u]\n&quot;, i, j, m, name,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       kernel_npc_perf_data_ptr-&gt;event[m]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for ( int k = STC_PTI_EVENT_ID_SYSDMA0_DMA_ID; k &lt; STC_PTI_EVENT_ID_MAX; k++ ){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                stcptiGetEventNameFromID(k, &amp;name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                STCpti_KernelDmaPerfData* kernel_dma_perf_data_ptr = </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &amp;(kernel_perf_datas_ptr-&gt;kernelDmaPerfData);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;kernel: %d dma event %02d %s [%u]\n&quot;, i, k, name,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               kernel_dma_perf_data_ptr-&gt;event[ k - STC_PTI_EVENT_ID_SYSDMA0_DMA_ID]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcptiKernelContextRelease();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcFree(dev_left);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcFree(dev_right);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcFree(dev_out);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>其中，STCPTI性能数据采集代码如下，省略号部分代表其他代码：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">......</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// !defined(__SHC_NPU_COMPILE__)宏用于控制仅在主机端代码进行编译时生效。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#if !defined(__SHC_NPU_COMPILE__)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;stcpti.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">......</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(void) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ......</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 定义用于记录性能数据的结构体。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    STCpti_PerfDatas perf_data = {0};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ......</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 为当前进程创建核函数性能数据采集的上下文。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcptiKernelContextCreate();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 开始采集性能数据。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcptiKernelEnable();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ......</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 执行核函数并等待执行完成。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    matmul_kernel&lt;&lt;&lt;NCORE&gt;&gt;&gt;(dev_out, dev_left, dev_right);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcDeviceSynchronize();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ......</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 获取核函数性能数据。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcptiKernelGetPerfDatas(&amp;perf_data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 停止采集性能数据。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcptiKernelDisable();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 输出核函数性能数据。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const char* name = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     for (int i = 0; i &lt; perf_data.kernelPerfDataSize; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        STCpti_KernelPerfDatas *kernel_perf_datas_ptr =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &amp;perf_data.pKernelPerfDatas[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int j = 0; j &lt; kernel_perf_datas_ptr-&gt;kernelNpcPerfDataSize; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            STCpti_KernelNpcPerfData *kernel_npc_perf_data_ptr =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &amp;kernel_perf_datas_ptr-&gt;arrKernelNpcPerfData[j];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int m = 0; m &lt; STC_PTI_EVENT_ID_SYSDMA0_DMA_ID; m++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                stcptiGetEventNameFromID(m, &amp;name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;kernel: %d npc: %d event %02d %s [%u]\n&quot;, i, j, m, name,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       kernel_npc_perf_data_ptr-&gt;event[m]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for ( int k = STC_PTI_EVENT_ID_SYSDMA0_DMA_ID; k &lt; STC_PTI_EVENT_ID_MAX; k++ ){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        stcptiGetEventNameFromID(k, &amp;name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        STCpti_KernelDmaPerfData* kernel_dma_perf_data_ptr = </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        &amp;(kernel_perf_datas_ptr-&gt;kernelDmaPerfData);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        printf(&quot;kernel: %d dma event %02d %s [%u]\n&quot;, i, k, name,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       kernel_dma_perf_data_ptr-&gt;event[ k - STC_PTI_EVENT_ID_SYSDMA0_DMA_ID]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 为当前进程释放核函数性能数据采集的上下文。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stcptiKernelContextRelease();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ......</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="c语言扩展接口">C++语言扩展接口<a href="#c语言扩展接口" class="hash-link" aria-label="Direct link to C++语言扩展接口" title="Direct link to C++语言扩展接口" translate="no">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="接口功能">接口功能<a href="#接口功能" class="hash-link" aria-label="Direct link to 接口功能" title="Direct link to 接口功能" translate="no">​</a></h4>
<p>SHC完整兼容C++17标准，并针对异构程序扩展了语法和函数库。基于SHC提供的运行时接口编写代码时，您可以使用C++扩展语言接口方便地控制执行代码的逻辑。</p>
<blockquote>
<p>说明：C++语言拓展接口详细说明，请参见<a href="https://docs.streamcomputing.com/_/sharing/vSxLMI20nalGphdpXdEVoDg6JkUcfEkT?next=/zh/latest/" target="_blank" rel="noopener noreferrer">C++ API</a>。</p>
</blockquote>
<p>主机端运行时接口提供以下功能：</p>
<ul>
<li>设备管理：提供操作设备（NPC Cluster）相关的功能，例如指定待使用的设备、获取设备信息等。</li>
<li>内存管理：提供操作内存相关的功能，例如分配/释放内存、拷贝内存数据等。</li>
<li>执行控制：提供执行目标程序相关的功能，例如注册/释放目标程序、指定运行配置、启动核函数、加载/卸载目标程序等。</li>
<li>流管理：提供操作流相关的功能，例如创建/销毁流、创建/销毁事件、添加事件等。</li>
<li>错误处理：提供获取错误信息相关的功能，例如获取错误码、获取错误详情等。</li>
</ul>
<p>设备端运行时接口则提供以下功能：</p>
<ul>
<li>设备查看：获取设备信息。</li>
<li>执行控制：退出核函数。</li>
<li>内存管理：在设备间拷贝内存。</li>
</ul>
<p>性能数据采集接口：采集异构程序的执行性能数据，获取MME、MTE等粒度的执行cycle数。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="调用核函数">调用核函数<a href="#调用核函数" class="hash-link" aria-label="Direct link to 调用核函数" title="Direct link to 调用核函数" translate="no">​</a></h4>
<p>在SHC中，调用核函数的方式如下：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">kernel_function&lt;&lt;&lt;NCORE, stream, flags&gt;&gt;&gt;(arg0, ...)</span><br></span></code></pre></div></div>
<p>命令中配置部分和参数部分的含义如下所示：</p>
<table><thead><tr><th><strong>命令内容</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>NCORE, stream, flags</td><td>指定设备端的配置，配置项含义如下：<br>NCORE：执行核函数所使用NPC的个数。<br>stream：指定执行核函数时所在的流，默认为0代表使用隐式声明流。详细的流使用说明，请参见<em>并行执行</em>章节。<br>flags：指定核函数的运行标志，默认为0（stcKernelFlagNone）代表无运行标志。详细的运行标志含义，请参见<em>stcKernelFlag_t</em>章节。</td></tr><tr><td>(arg0, ...)</td><td>指定核函数的参数，参数需要满足以下条件：<br>参数列表中的变量类型和个数必须和核函数的定义相匹配。<br>每个参数的大小不能超过4字节。</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="函数修饰符">函数修饰符<a href="#函数修饰符" class="hash-link" aria-label="Direct link to 函数修饰符" title="Direct link to 函数修饰符" translate="no">​</a></h4>
<p>SHC支持函数修饰符<code>__host__</code>、<code>__global__</code>、<code>__device__</code>，用于区分不同用途的函数。函数修饰符以及函数用途说明如下所示：</p>
<table><thead><tr><th><strong>函数用途</strong></th><th><strong>修饰符</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>主机端函数</td><td><code>__host__</code></td><td>具有以下特点：<br>在主机端执行，对设备端程序不可见。<br>主机端函数中可以调用主机端函数、核函数、双边函数，可以使用STL、libc、libc++库，支持递归调用自身。<br>参数来自于用户输入。<br>与普通C++函数没有任何区别，可以作为函数模板、类方法或匿名函数。<br>说明：如果函数没有添加任何函数修饰符，默认是主机端函数，编译器会自动添加函数修饰符。</td></tr><tr><td>核函数</td><td><code>__global__</code></td><td>具有以下特点：<br>能且只能由主机端函数调用，并在设备端执行。<br>核函数中可以调用设备端函数、双边函数，可以使用libnpurt库。<br>从栈上取参数。<br>能且只能是普通函数。返回类型必须是void。<br>具有以下限制：<br>不支持递归调用自身。<br>不能包含<code>long</code>、<code>longlong</code>或<code>double</code>类型的参数。<br>不支持使用其他变量修饰符修饰核函数的参数。</td></tr><tr><td>设备端函数</td><td><code>__device__</code></td><td>具有以下特点：<br>在设备端执行，对主机端程序不可见。<br>设备端函数中可以调用设备端函数、双边函数，可以使用libnpurt库，支持递归调用自身。<br>从寄存器取参数。<br>与普通C++函数没有任何区别，可以作为函数模板、类方法或匿名函数。<br>说明：如果需要函数需要在设备端执行，则不可省略函数修饰符。</td></tr><tr><td>双边函数</td><td><code>__host__</code>和<code>__device__</code></td><td>具有以下特点：<br>可以在主机端、设备端执行。<br>能且只能调用双边函数，支持递归调用自身。<br>可以被主机端函数、核函数、双边函数调用，参数来自于调用者。<br>双边函数一般是一些主机端和设备端都会用到的小型辅助函数，例如求数组最大值。</td></tr></tbody></table>
<blockquote>
<p>说明：不建议使用<code>__device__</code>和<code>__host__</code>各自修饰类方法，会导致在主机端和设备端看到的类定义不同。</p>
</blockquote>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="变量修饰符">变量修饰符<a href="#变量修饰符" class="hash-link" aria-label="Direct link to 变量修饰符" title="Direct link to 变量修饰符" translate="no">​</a></h4>
<p>设备端不支持动态分配内存，但SHC支持通过变量修饰符<code>__device__</code>、 <code>__local__</code>、 <code>__shared__</code>、 <code>__mutable__</code>静态分配内存。每种变量修饰符对应不同的分配规则，各变量类型的基本属性如下：</p>
<table><thead><tr><th><strong>变量修饰符</strong></th><th><strong>存放位置</strong></th><th><strong>有效范围</strong></th><th><strong>读写属性</strong></th><th><strong>变量初始化</strong></th><th><strong>多核访问</strong></th></tr></thead><tbody><tr><td><code>__device__</code></td><td>全局内存</td><td>全局变量、全局静态变量、局部变量、静态局部变量</td><td>单独使用：只读<br>和<code>__thread</code>联用：可读写</td><td>只读时，必须显式初始化。</td><td>单独使用：可以被多个核共同访问。<br>和<code>__thread</code>联用：变量在每个核都保存一份副本。对单核上的副本的修改，对其它核不可见。</td></tr><tr><td><code>__local__</code></td><td>本地内存</td><td>局部变量</td><td>可读写</td><td>推荐定义<code>__local__</code>数组作为buffer使用。<br>说明：<code>__local__</code>变量允许初始化，但是初始化会降低执行效率，因此不推荐初始化。</td><td>定义的<code>__local__</code>变量在每个NPC都保存一份副本。对单核上的副本的修改，对其它核不可见。</td></tr><tr><td><code>__shared__</code></td><td>共享内存</td><td>局部变量</td><td>可读写</td><td>推荐定义<code>__shared__</code>数组作为buffer使用。<br>说明：<code>__shared__</code>变量允许初始化，但是初始化会降低执行效率，因此不推荐初始化。另外，如果需要从多个NPC访问<code>__shared__</code>变量，读写变量前注意执行sync指令，保证在多个NPC中完成并发初始化。</td><td>定义的<code>__shared__</code>变量可以被多个NPC共同访问。如果希望使用<code>__shared__</code>变量在NPC间传递信息，需要使用<code>volatile</code>修饰。</td></tr><tr><td><code>__mutable__</code><br>说明：不能单独使用，需要和<code>__device__</code>一起使用，且不可以修饰指针。</td><td>全局内存</td><td>全局变量、全局静态变量、局部变量、局部静态变量<br>说明：全局变量地址默认非32字节对齐，您需要自行添加对齐属性<code>__attribute__((aligned(32)))</code>。</td><td>可读写</td><td>可读写，因此无需显式初始化。</td><td>定义的<code>__mutable__</code>变量可以被多个核共同访问。如果希望使用<code>__mutable__</code>变量在核间传递信息，需要使用<code>volatile</code>修饰。</td></tr><tr><td><code>__imb__</code></td><td>本地内存</td><td>局部变量</td><td>可读写</td><td><code>__imb__</code>变量不允许初始化，只能作为高速buffer使用。</td><td>定义的<code>__imb__</code>变量在每个NPC都保存一份副本。对单核上的副本的修改，对其它核不可见。</td></tr></tbody></table>
<p>变量类型会影响访问速度和内存占用情况：</p>
<ul>
<li>访问速度<!-- -->
<ul>
<li>由变量存放位置决定，本地内存最快（<code>__local__</code>、<code>__imb__</code>），共享内存次之（<code>__shared__</code>），全局内存最慢（<code>__device__</code>、<code>__mutable__</code>）。</li>
</ul>
</li>
<li>内存占用<!-- -->
<ul>
<li>函数内所有的<code>__imb__</code>变量和<code>__local__</code>变量的总大小不能超出本地内存空间（1.25MiB）。</li>
<li>函数内所有的<code>__shared__</code>变量的总大小不能超出共享内存空间（8MiB）。</li>
<li><code>__local__</code>、<code>__shared__</code>、<code>__imb__</code>所需内存在调用函数时动态分配，因此未调用函数时不占用空间，递归调用会占用多倍空间。</li>
<li>全局内存空间（4GiB）充足，不太可能出现超出问题。</li>
</ul>
</li>
</ul>
<p>使用本章节所述的变量修饰符时，请注意以下限制：</p>
<ul>
<li>仅支持在核函数、设备端函数中使用，不支持在主机端函数、双边函数中使用。</li>
<li>变量修饰符都不支持修饰函数参数。</li>
<li>变量修饰符都不支持修饰C++对象，仅支持修饰POD类型（例如普通变量、数组、结构体）。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="python语言扩展接口">Python语言扩展接口<a href="#python语言扩展接口" class="hash-link" aria-label="Direct link to Python语言扩展接口" title="Direct link to Python语言扩展接口" translate="no">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="接口功能-1">接口功能<a href="#接口功能-1" class="hash-link" aria-label="Direct link to 接口功能" title="Direct link to 接口功能" translate="no">​</a></h4>
<p>基于HPE异构编程模型和C++语言扩展接口的设计，我们还提供了Python接口方便您在Python项目中使用HPE异构编程能力。在安装了HPE异构编程环境的机器上进入符合要求的Python环境并安装HPE Python扩展库，即可使用主机端运行时（hpert）和性能数据采集（stcpti）的Python接口。</p>
<blockquote>
<p>说明：Python语言拓展接口详细说明，请参见<a href="https://docs.streamcomputing.com/_/sharing/vSxLMI20nalGphdpXdEVoDg6JkUcfEkT?next=/zh/latest/" target="_blank" rel="noopener noreferrer">Python API</a>。</p>
</blockquote>
<p>主机端运行时接口提供了以下功能：</p>
<ul>
<li>设备管理：提供操作设备相关的功能，例如指定待使用的设备、获取设备信息等。</li>
<li>内存管理：提供操作内存相关的功能，例如分配/释放内存、拷贝内存数据等。</li>
<li>执行控制：提供执行目标程序相关的功能，例如指定运行配置、加载/卸载目标程序。</li>
<li>流管理：提供操作流相关的功能，例如创建/销毁流、创建/销毁事件、添加事件等。</li>
</ul>
<blockquote>
<p>说明：主机端运行时接口执行报错时，会通过异常（RuntimeAPIError）方式上报错误码，您可以通过返回的Error Message定位和排查问题。详细的Error Message及说明，请参见<a href="https://docs.streamcomputing.com/_/sharing/vSxLMI20nalGphdpXdEVoDg6JkUcfEkT?next=/zh/latest/" target="_blank" rel="noopener noreferrer">Python API</a>中<em>class hpe.hpert.api.CruntimeException</em>章节的说明。</p>
</blockquote>
<p>性能数据采集接口：采集异构程序的执行性能数据，获取MME、MTE等粒度的执行cycle数。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="使用示例">使用示例<a href="#使用示例" class="hash-link" aria-label="Direct link to 使用示例" title="Direct link to 使用示例" translate="no">​</a></h4>
<ol>
<li>
<p>编写并编译设备端程序。设备端程序需要用C++实现，因此需要单独编译后供Python实现的主机端程序读入。示例程序的作用是使用指定的核在数组间拷贝数据。编译时将copy.cc编译为copy.o，并用copy.o生成Fat Binary文件copy-fatbin.o。</p>
<div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ cat copy.cc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;npurt.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">extern &quot;C&quot; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void copy(int *in, int *out, int num) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (CoreID == 0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i=0; i&lt;num; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                out[i] = in[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ stc-clang++ --target=riscv32npu -c copy.cc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ stc-ld.lld -flavor gnu copy.o /usr/local/hpe/riscv32npu/lib/libnpurt_hld.a -r -o copy-fatbin.o</span><br></span></code></pre></div></div>
</li>
<li>
<p>编写并运行主机端程序。示例程序用Python实现，其中读入了已经单独编译得到的设备端目标程序。示例程序的作用是使用主机端运行时接口从主机端向设备端拷贝100个整数，然后拷贝回主机端，同时使用性能数据采集接口获取过程中的性能数据。</p>
<div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ cat copy-example.py</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#!/usr/bin/env python</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># coding=utf-8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import numpy as np</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import hpe.hpert.api as hpe</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import hpe.profiler.api as prof</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">def main():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &#x27;&#x27;&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    copy 100 integers from host to device and then back to host</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &#x27;&#x27;&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    DATA_NUM = 100</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print(&quot;version&quot;, hpe.version())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hpe.detect()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print(&#x27;get device:&#x27;, hpe.get_device())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        prof.init()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        prof.enable()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # prepare host memory</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        host_in = np.arange(DATA_NUM, dtype=np.int32)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        host_out = np.zeros(DATA_NUM, dtype=np.int32)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # prepare device memory</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        device_in = hpe.device_mem(host_in.nbytes)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        device_out = hpe.device_mem(host_out.nbytes)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # move 100 integers from host to device</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        device_in.copy_from_host(host_in)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # &#x27;hello&#x27; kernel function in hello.o moves 100 integers from device_in to device_out</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mod = hpe.module(&#x27;copy-fatbin.o&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mod.launch_kernel(&#x27;copy&#x27;, [device_in, device_out, DATA_NUM])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hpe.synchronize()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # move 100 integers from device to host</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        device_out.copy_to_host(host_out)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print(&quot;host_out:&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print(host_out)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        prof.disable()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        perf_datas = prof.get_perf_datas()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print(&quot;*************profiler data*************&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print(perf_datas)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        prof.release()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    except hpe.CruntimeException as e:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print(e)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if __name__ == &quot;__main__&quot;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    main()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ python copy-example.py</span><br></span></code></pre></div></div>
</li>
</ol></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/希姆计算开发者资源/STCRP开发指南.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/希姆计算开发者资源/Python API"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Python API</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/希姆计算开发者资源/模型支持说明"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">模型支持说明</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#hpe异构编程指南" class="table-of-contents__link toc-highlight">HPE异构编程指南</a><ul><li><a href="#异构编程模型" class="table-of-contents__link toc-highlight">异构编程模型</a></li><li><a href="#异构编程典型操作" class="table-of-contents__link toc-highlight">异构编程典型操作</a></li><li><a href="#c语言扩展接口" class="table-of-contents__link toc-highlight">C++语言扩展接口</a></li><li><a href="#python语言扩展接口" class="table-of-contents__link toc-highlight">Python语言扩展接口</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/希姆计算术语表">希姆计算术语</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://x.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">X<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>