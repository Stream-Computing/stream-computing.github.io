<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-希姆计算开发者资源/C++ API" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.9.1">
<title data-rh="true">C++ API | 文档中心</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://your-docusaurus-site.example.com/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://your-docusaurus-site.example.com/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://your-docusaurus-site.example.com/docs/希姆计算开发者资源/C++ API"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="C++ API | 文档中心"><meta data-rh="true" name="description" content="HPE主机端运行时API"><meta data-rh="true" property="og:description" content="HPE主机端运行时API"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://your-docusaurus-site.example.com/docs/希姆计算开发者资源/C++ API"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/docs/希姆计算开发者资源/C++ API" hreflang="en"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/docs/希姆计算开发者资源/C++ API" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"C++ API","item":"https://your-docusaurus-site.example.com/docs/希姆计算开发者资源/C++ API"}]}</script><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="文档中心 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="文档中心 Atom Feed"><link rel="stylesheet" href="/assets/css/styles.59b7a052.css">
<script src="/assets/js/runtime~main.462312d6.js" defer="defer"></script>
<script src="/assets/js/main.327d30a9.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",t||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")),document.documentElement.setAttribute("data-theme-choice",t||"system")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/img/stc_logo.svg"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/stc_logo.svg" alt="" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/stc_logo.svg" alt="" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">STC DOCS HUB</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">文档</a><a class="navbar__item navbar__link" href="/blog">动态</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://www.streamcomputing.com/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">希姆计算<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro"><span title="Tutorial Intro" class="linkLabel_WmDU">Tutorial Intro</span></a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist" href="/docs/category/tutorial---basics"><span title="Tutorial - Basics" class="categoryLinkLabel_W154">Tutorial - Basics</span></a><button aria-label="Expand sidebar category &#x27;Tutorial - Basics&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist" href="/docs/category/tutorial---extras"><span title="Tutorial - Extras" class="categoryLinkLabel_W154">Tutorial - Extras</span></a><button aria-label="Expand sidebar category &#x27;Tutorial - Extras&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/希姆计算产品运维/k8s-device-plugin使用指南"><span title="希姆计算产品运维" class="categoryLinkLabel_W154">希姆计算产品运维</span></a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/希姆计算介绍"><span title="希姆计算" class="linkLabel_WmDU">希姆计算</span></a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" href="/docs/希姆计算开发者资源/C++ API"><span title="希姆计算开发者资源" class="categoryLinkLabel_W154">希姆计算开发者资源</span></a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/希姆计算开发者资源/C++ API"><span title="C++ API" class="linkLabel_WmDU">C++ API</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/希姆计算开发者资源/HPE错误信息分类标识"><span title="HPE错误信息分类标识" class="linkLabel_WmDU">HPE错误信息分类标识</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/希姆计算开发者资源/MLTC算子支持说明"><span title="MLTC算子支持说明" class="linkLabel_WmDU">MLTC算子支持说明</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/希姆计算开发者资源/Python API"><span title="Python API" class="linkLabel_WmDU">Python API</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/希姆计算开发者资源/STCRP开发指南"><span title="STCRP开发指南" class="linkLabel_WmDU">STCRP开发指南</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/希姆计算开发者资源/模型支持说明"><span title="模型支持说明" class="linkLabel_WmDU">模型支持说明</span></a></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/希姆计算术语表"><span title="希姆计算术语表" class="linkLabel_WmDU">希姆计算术语表</span></a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/希姆计算硬件产品/STCP920产品手册"><span title="希姆计算硬件产品" class="categoryLinkLabel_W154">希姆计算硬件产品</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/希姆计算解决方案/希姆算力云平台解决方案"><span title="希姆计算解决方案" class="categoryLinkLabel_W154">希姆计算解决方案</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/希姆计算软件产品/Firmware Release Notes"><span title="希姆计算软件产品" class="categoryLinkLabel_W154">希姆计算软件产品</span></a></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">希姆计算开发者资源</span></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">C++ API</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>C++ API</h1></header>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="hpe主机端运行时api">HPE主机端运行时API<a href="#hpe主机端运行时api" class="hash-link" aria-label="Direct link to HPE主机端运行时API" title="Direct link to HPE主机端运行时API" translate="no">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="调用要求">调用要求<a href="#调用要求" class="hash-link" aria-label="Direct link to 调用要求" title="Direct link to 调用要求" translate="no">​</a></h3>
<p>调用HPE主机端运行时API时，请确保：</p>
<ul>
<li>
<p>已安装HPE。具体操作，请参见<a href="https://docs.streamcomputing.com/_/sharing/vSxLMI20nalGphdpXdEVoDg6JkUcfEkT?next=/zh/latest/" target="_blank" rel="noopener noreferrer">STCRP安装指南</a>。</p>
</li>
<li>
<p>在代码文件中导入所需的头文件，包括但不限于：</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;hpe.h&gt;</span><br></span></code></pre></div></div>
</li>
</ul>
<blockquote>
<p>说明：系统的HPE异构编程介绍，请参见<a href="https://docs.streamcomputing.com/_/sharing/vSxLMI20nalGphdpXdEVoDg6JkUcfEkT?next=/zh/latest/" target="_blank" rel="noopener noreferrer">STCRP开发指南</a>，安装HPE后自带的异构编程示例，请参见<a href="https://docs.streamcomputing.com/_/sharing/vSxLMI20nalGphdpXdEVoDg6JkUcfEkT?next=/zh/latest/" target="_blank" rel="noopener noreferrer">HPE使用指南</a>。</p>
</blockquote>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="调用限制">调用限制<a href="#调用限制" class="hash-link" aria-label="Direct link to 调用限制" title="Direct link to 调用限制" translate="no">​</a></h3>
<ul>
<li>因为PCIe BAR0空间增大为16GB，不能在大部分桌面型CPU平台上运行（例如物理地址寻址位数小于40的CPU）。</li>
<li>在没有PCIe Switch的Intel平台上，存在P2P性能很差的问题（约为0.85GB/s）。</li>
<li>在带PCIe Switch的Intel平台上，跨NUMA的P2P存在性能很差的问题（约为0.85GB/s）。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="接口说明">接口说明<a href="#接口说明" class="hash-link" aria-label="Direct link to 接口说明" title="Direct link to 接口说明" translate="no">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="设备管理">设备管理<a href="#设备管理" class="hash-link" aria-label="Direct link to 设备管理" title="Direct link to 设备管理" translate="no">​</a></h4>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcsetdevice">stcSetDevice<a href="#stcsetdevice" class="hash-link" aria-label="Direct link to stcSetDevice" title="Direct link to stcSetDevice" translate="no">​</a></h5>
<p>函数描述：调用stcSetDevice设置用于执行设备端程序的NPC Cluster。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcSetDevice (int device)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>device</td><td>输入参数</td><td>int</td><td>NPC Cluster ID，由NPU设备标识符、NPC Cluster设备标识符推导得出。详细的推导说明，请参见<em>指定NPC Cluster ID</em>章节。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcgetdevice">stcGetDevice<a href="#stcgetdevice" class="hash-link" aria-label="Direct link to stcGetDevice" title="Direct link to stcGetDevice" translate="no">​</a></h5>
<p>函数描述：调用stcGetDevice获取用于执行设备端程序的NPC Cluster。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcGetDevice (int *device)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>device</td><td>输出参数</td><td>int*</td><td>指向所获取NPC Cluster ID的指针。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcgetdeviceattribute">stcGetDeviceAttribute<a href="#stcgetdeviceattribute" class="hash-link" aria-label="Direct link to stcGetDeviceAttribute" title="Direct link to stcGetDeviceAttribute" translate="no">​</a></h5>
<p>函数描述：调用stcGetDeviceAttribute获取一个NPC Cluster所在NPU的属性，例如NPU硬件版本、NPC Cluster数量等。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcGetDeviceAttribute (int *value, stcDeviceAttr attr, int device)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>value</td><td>输出参数</td><td>int*</td><td>指向所获取属性数据的指针。</td></tr><tr><td>attr</td><td>输入参数</td><td>stcDeviceAttr</td><td>属性名称，例如代表NPU硬件版本的stcDevAttrChipHWVersion。详细的属性名称含义，请参见<em>stcDeviceAttr</em>章节。</td></tr><tr><td>device</td><td>输入参数</td><td>int</td><td>NPC Cluster ID。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcgetdevicename">stcGetDeviceName<a href="#stcgetdevicename" class="hash-link" aria-label="Direct link to stcGetDeviceName" title="Direct link to stcGetDeviceName" translate="no">​</a></h5>
<p>函数描述：调用stcGetDeviceName获取一个NPC Cluster所在NPU的设备名称。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcGetDeviceName (const char **name, int device)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>name</td><td>输出参数</td><td>const char **</td><td>指向所获取设备名称的二级指针。</td></tr><tr><td>device</td><td>输入参数</td><td>int</td><td>NPC Cluster ID。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcgetdevicecount">stcGetDeviceCount<a href="#stcgetdevicecount" class="hash-link" aria-label="Direct link to stcGetDeviceCount" title="Direct link to stcGetDeviceCount" translate="no">​</a></h5>
<p>函数描述：调用stcGetDeviceCount获取所有NPU上NPC Cluster的数量。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcGetDeviceCount (int *count)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>count</td><td>输出参数</td><td>int*</td><td>指向所获取NPC Cluster数量的指针。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcdevicesynchronize">stcDeviceSynchronize<a href="#stcdevicesynchronize" class="hash-link" aria-label="Direct link to stcDeviceSynchronize" title="Direct link to stcDeviceSynchronize" translate="no">​</a></h5>
<p>函数描述：调用stcDeviceSynchronize等待当前进程的所有设备端操作执行结束。如果核函数执行异常退出，则输出触发异常时核函数的调用栈。</p>
<blockquote>
<p>说明：只在对应cluster上有效，不能用来推测其他cluster的状态。</p>
</blockquote>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcDeviceSynchronize (void)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<p>无</p>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="内存管理">内存管理<a href="#内存管理" class="hash-link" aria-label="Direct link to 内存管理" title="Direct link to 内存管理" translate="no">​</a></h4>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcmalloc">stcMalloc<a href="#stcmalloc" class="hash-link" aria-label="Direct link to stcMalloc" title="Direct link to stcMalloc" translate="no">​</a></h5>
<p>函数描述：调用stcMalloc在设备端全局内存的0GiB ~ 3GiB范围动态分配内存。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcMalloc (void **devPtr, size_t size)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>devPtr</td><td>输出参数</td><td>void**</td><td>指向所分配内存地址的指针。</td></tr><tr><td>size</td><td>输入参数</td><td>size_t</td><td>所需分配的内存大小，单位为字节。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcmallochigh">stcMallocHigh<a href="#stcmallochigh" class="hash-link" aria-label="Direct link to stcMallocHigh" title="Direct link to stcMallocHigh" translate="no">​</a></h5>
<p>函数描述：调用stcMallocHigh在设备端全局内存的3GiB ~ 4GiB范围（也称为高端内存）动态分配内存。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcMallocHigh(void **devPtr, size_t size)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>devPtr</td><td>输出参数</td><td>void**</td><td>指向所分配内存地址的指针。</td></tr><tr><td>size</td><td>输入参数</td><td>size_t</td><td>所需分配的内存大小，单位为字节。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcfree">stcFree<a href="#stcfree" class="hash-link" aria-label="Direct link to stcFree" title="Direct link to stcFree" translate="no">​</a></h5>
<p>函数描述：调用stcFree释放在设备端动态分配的全局内存。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcFree (void *devPtr)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>devPtr</td><td>输入参数</td><td>void*</td><td>指向待释放内存的指针。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcmallochost">stcMallocHost<a href="#stcmallochost" class="hash-link" aria-label="Direct link to stcMallocHost" title="Direct link to stcMallocHost" translate="no">​</a></h5>
<p>函数描述：调用stcMallocHost在主机端分配内存，并设置为不会被换出的页锁定内存。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcMallocHost (void **ptr, size_t size)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>ptr</td><td>输出参数</td><td>void**</td><td>指向所分配内存地址的指针。</td></tr><tr><td>size</td><td>输入参数</td><td>size_t</td><td>所需分配的内存大小，单位为字节。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcfreehost">stcFreeHost<a href="#stcfreehost" class="hash-link" aria-label="Direct link to stcFreeHost" title="Direct link to stcFreeHost" translate="no">​</a></h5>
<p>函数描述：调用stcFreeHost释放在主机端分配的页锁定内存。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcFreeHost (void *ptr)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>ptr</td><td>输入参数</td><td>void*</td><td>指向待释放内存的指针。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stchostregister">stcHostRegister<a href="#stchostregister" class="hash-link" aria-label="Direct link to stcHostRegister" title="Direct link to stcHostRegister" translate="no">​</a></h5>
<p>函数描述：调用stcHostRegister将主机端的内存设置为不会被换出的页锁定内存。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcHostRegister (void *ptr, size_t size)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>ptr</td><td>输入参数</td><td>void*</td><td>指向待锁定内存的指针。</td></tr><tr><td>size</td><td>输入参数</td><td>size_t</td><td>所需锁定的内存大小，单位为字节。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stchostunregister">stcHostUnregister<a href="#stchostunregister" class="hash-link" aria-label="Direct link to stcHostUnregister" title="Direct link to stcHostUnregister" translate="no">​</a></h5>
<p>函数描述：调用stcHostUnregister解锁主机端的页锁定内存。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcHostUnregister (void *ptr)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>ptr</td><td>输入参数</td><td>void*</td><td>指向待解锁内存的指针。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcmemcpy">stcMemcpy<a href="#stcmemcpy" class="hash-link" aria-label="Direct link to stcMemcpy" title="Direct link to stcMemcpy" translate="no">​</a></h5>
<p>函数描述：调用stcMemcpy拷贝内存，该函数支持主机间拷贝、主机端向设备端拷贝、设备端向主机端拷贝。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcMemcpy (void *dst, const void *src, size_t count, stcMemcpyKind kind)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>dst</td><td>输入参数</td><td>void*</td><td>拷贝操作的目的地址，向该指针指向的内存写入数据。</td></tr><tr><td>src</td><td>输入参数</td><td>const void*</td><td>拷贝操作的源地址，从该指针指向的内存读取数据。</td></tr><tr><td>count</td><td>输入参数</td><td>size_t</td><td>待拷贝内存的大小，单位为字节。</td></tr><tr><td>kind</td><td>输入参数</td><td>stcMemcpyKind</td><td>拷贝的方向，支持主机间拷贝、主机端向设备端拷贝、设备端向主机端。详细的类型说明，请参见<em>stcMemcpyKind</em>章节。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcmemcpyasync">stcMemcpyAsync<a href="#stcmemcpyasync" class="hash-link" aria-label="Direct link to stcMemcpyAsync" title="Direct link to stcMemcpyAsync" translate="no">​</a></h5>
<p>函数描述：调用stcMemcpyAsync异步拷贝内存，调用后立即返回，不用等待拷贝完成。该函数支持主机间拷贝、主机端向设备端全局内存拷贝、设备端全局内存向主机端拷贝。</p>
<p>函数类型：异步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcMemcpyAsync (void *dst, const void *src, size_t count, stcMemcpyKind kind, stcStream_t stream=0)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>dst</td><td>输入参数</td><td>void*</td><td>拷贝操作的目的地址，向该指针指向的内存写入数据。</td></tr><tr><td>src</td><td>输入参数</td><td>const void*</td><td>拷贝操作的源地址，从该指针指向的内存读取数据。</td></tr><tr><td>count</td><td>输入参数</td><td>size_t</td><td>待拷贝内存的大小，单位为字节。</td></tr><tr><td>kind</td><td>输入参数</td><td>stcMemcpyKind</td><td>拷贝的方向，支持主机间拷贝、主机端向设备端拷贝、设备端向主机端。详细的类型说明，请参见<em>stcMemcpyKind</em>章节。</td></tr><tr><td>stream</td><td>输入参数</td><td>stcStream_t</td><td>流标识符，默认为0，代表隐式声明流。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcmemcpypeer">stcMemcpyPeer<a href="#stcmemcpypeer" class="hash-link" aria-label="Direct link to stcMemcpyPeer" title="Direct link to stcMemcpyPeer" translate="no">​</a></h5>
<p>函数描述：调用stcMemcpyPeer在NPC Cluster间拷贝全局内存。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcMemcpyPeer (void *dst, int dstDevice, const void *src, int srcDevice, size_t count)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>dst</td><td>输入参数</td><td>void*</td><td>拷贝操作的目的地址，向该指针指向的内存写入数据。</td></tr><tr><td>dstDevice</td><td>输入参数</td><td>int</td><td>目的NPC Cluster的ID。</td></tr><tr><td>src</td><td>输入参数</td><td>const void*</td><td>拷贝操作的源地址，从该指针指向的内存读取数据。</td></tr><tr><td>srcDevice</td><td>输入参数</td><td>int</td><td>源NPC Cluster的ID。</td></tr><tr><td>count</td><td>输入参数</td><td>size_t</td><td>待拷贝内存的大小，单位为字节。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcmemcpypeerasync">stcMemcpyPeerAsync<a href="#stcmemcpypeerasync" class="hash-link" aria-label="Direct link to stcMemcpyPeerAsync" title="Direct link to stcMemcpyPeerAsync" translate="no">​</a></h5>
<p>函数描述：调用stcMemcpyPeerAsync在NPC Cluster间异步拷贝全局内存，调用后立即返回，不用等待拷贝完成。</p>
<p>函数类型：异步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcMemcpyPeerAsync (void *dst, int dstDevice, const void *src, int srcDevice, size_t count, stcStream_t stream=0)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>dst</td><td>输入参数</td><td>void*</td><td>拷贝操作的目的地址，向该指针指向的内存写入数据。</td></tr><tr><td>dstDevice</td><td>输入参数</td><td>int</td><td>目的NPC Cluster的ID。</td></tr><tr><td>src</td><td>输入参数</td><td>const void*</td><td>拷贝操作的源地址，从该指针指向的内存读取数据。</td></tr><tr><td>srcDevice</td><td>输入参数</td><td>int</td><td>源NPC Cluster的ID。</td></tr><tr><td>count</td><td>输入参数</td><td>size_t</td><td>待拷贝内存的大小，单位为字节。</td></tr><tr><td>stream</td><td>输入参数</td><td>stcStream_t</td><td>流标识符，默认为0，代表隐式声明流。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="执行控制">执行控制<a href="#执行控制" class="hash-link" aria-label="Direct link to 执行控制" title="Direct link to 执行控制" translate="no">​</a></h4>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcregisterfatbinary">stcRegisterFatBinary<a href="#stcregisterfatbinary" class="hash-link" aria-label="Direct link to stcRegisterFatBinary" title="Direct link to stcRegisterFatBinary" translate="no">​</a></h5>
<p>函数描述：调用stcRegisterFatBinary注册在设备端执行的目标程序。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcRegisterFatBinary (const void *data)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>data</td><td>输入参数</td><td>const void*</td><td>指向目标程序所占内存的指针。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcunregisterfatbinary">stcUnregisterFatBinary<a href="#stcunregisterfatbinary" class="hash-link" aria-label="Direct link to stcUnregisterFatBinary" title="Direct link to stcUnregisterFatBinary" translate="no">​</a></h5>
<p>函数描述：调用stcUnregisterFatBinary释放所有已注册的目标程序。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcUnregisterFatBinary (void)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<p>无</p>
<p>函数返回值：</p>
<p>stcSuccess</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcconfigurecall">stcConfigureCall<a href="#stcconfigurecall" class="hash-link" aria-label="Direct link to stcConfigureCall" title="Direct link to stcConfigureCall" translate="no">​</a></h5>
<p>函数描述：调用stcConfigureCall指定执行核函数的配置。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcConfigureCall(int core_num, stcStream_t stream=0, unsigned int flags=stcKernelFlagNone)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>core_num</td><td>输入参数</td><td>int</td><td>在一个NPC Cluster上并行执行核函数所使用的NPC个数。</td></tr><tr><td>stream</td><td>输入参数</td><td>stcStream_t</td><td>流标识符，默认为0，代表将配置应用于隐式声明流。</td></tr><tr><td>flags</td><td>输入参数</td><td>unsigned int</td><td>指定核函数的运行标志，默认无运行标志（stcKernelFlagNone）。详细的运行标志含义，请参见<em>stcKernelFlag_t</em>章节。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stclaunchkernel">stcLaunchKernel<a href="#stclaunchkernel" class="hash-link" aria-label="Direct link to stcLaunchKernel" title="Direct link to stcLaunchKernel" translate="no">​</a></h5>
<p>函数描述：调用stcLaunchKernel启动核函数。</p>
<p>函数类型：异步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcLaunchKernel（stcModule_t *module, const char *kname, stcKernelParams_t kernelParams)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>module</td><td>输出参数</td><td>stcModule_t*</td><td>指向核函数所在目标程序模块的指针。</td></tr><tr><td>kname</td><td>输入参数</td><td>const char*</td><td>核函数的名称。</td></tr><tr><td>kernelParams</td><td>输入参数</td><td>stcKernelParams_t</td><td>核函数的参数信息。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcmoduleloaddata">stcModuleLoadData<a href="#stcmoduleloaddata" class="hash-link" aria-label="Direct link to stcModuleLoadData" title="Direct link to stcModuleLoadData" translate="no">​</a></h5>
<p>函数描述：调用stcModuleLoadData将目标程序加载到设备端。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcModuleLoadData (stcModule_t *module, const void *data, size_t size)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>module</td><td>输出参数</td><td>stcModule_t*</td><td>指向加载到设备端的目标程序模块的指针。</td></tr><tr><td>data</td><td>输入参数</td><td>const void*</td><td>待加载目标程序的内存地址。</td></tr><tr><td>size</td><td>输入参数</td><td>size_t</td><td>待加载目标程序占用的内存大小，单位为字节。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcmoduleunload">stcModuleUnload<a href="#stcmoduleunload" class="hash-link" aria-label="Direct link to stcModuleUnload" title="Direct link to stcModuleUnload" translate="no">​</a></h5>
<p>函数描述：调用stcModuleUnload从设备端卸载目标程序模块。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcModuleUnload (stcModule_t module)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>module</td><td>输入参数</td><td>stcModule_t</td><td>待释放的目标程序模块。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="流管理">流管理<a href="#流管理" class="hash-link" aria-label="Direct link to 流管理" title="Direct link to 流管理" translate="no">​</a></h4>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcstreamcreate">stcStreamCreate<a href="#stcstreamcreate" class="hash-link" aria-label="Direct link to stcStreamCreate" title="Direct link to stcStreamCreate" translate="no">​</a></h5>
<p>函数描述：调用stcStreamCreate在cluster范围内创建一个具有DividedHS模式的流。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcStreamCreate (stcStream_t *pStream)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>pStream</td><td>输出参数</td><td>stcStream_t*</td><td>指向创建的流标识符的指针。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>返回值为0：成功；返回值为其他值：错误码，其中详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcstreamcreateunified">stcStreamCreateUnified<a href="#stcstreamcreateunified" class="hash-link" aria-label="Direct link to stcStreamCreateUnified" title="Direct link to stcStreamCreateUnified" translate="no">​</a></h5>
<p>函数描述：使用stcStreamCreateUnified在NPU范围内创建的一个具有UnifiedHS模式的流。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcStreamCreateUnified(stcStream_t *pStream)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>pStream</td><td>输出参数</td><td>stcStream_t*</td><td>指向创建的流标识符的指针。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>返回值为0：成功；返回值为其他值：错误码，其中详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcstreamdestroy">stcStreamDestroy<a href="#stcstreamdestroy" class="hash-link" aria-label="Direct link to stcStreamDestroy" title="Direct link to stcStreamDestroy" translate="no">​</a></h5>
<p>函数描述：调用stcStreamDestroy销毁指定流。如果流中有未完成的操作，会终止执行并释放相关资源。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcStreamDestroy (stcStream_t stream)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stream</td><td>输入参数</td><td>stcStream_t</td><td>待销毁流的标识符。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>返回值为0：成功；返回值为其他值：错误码，其中详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcstreamdestroyunified">stcStreamDestroyUnified<a href="#stcstreamdestroyunified" class="hash-link" aria-label="Direct link to stcStreamDestroyUnified" title="Direct link to stcStreamDestroyUnified" translate="no">​</a></h5>
<p>函数描述：调用stcStreamDestroyUnified销毁指定的UnifiedHS流。在销毁前会清除正在运行和待运行的任务。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcStreamDestroyUnified(stcStream_t pStream)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>pstream</td><td>输入参数</td><td>stcStream_t</td><td>待销毁流的标识符。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>返回值为0：成功；返回值为其他值：错误码，其中详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcstreamsynchronize">stcStreamSynchronize<a href="#stcstreamsynchronize" class="hash-link" aria-label="Direct link to stcStreamSynchronize" title="Direct link to stcStreamSynchronize" translate="no">​</a></h5>
<p>函数描述：调用stcStreamSynchronize等待指定流上的所有操作执行结束。如果核函数执行异常退出，则输出触发异常时核函数的调用栈。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcStreamSynchronize (stcStream_t stream)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stream</td><td>输入参数</td><td>stcStream_t</td><td>流标识符，等待该流上的所有操作执行结束。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>返回值为0：成功；返回值为其他值：错误码，其中详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcstreamsynchronizeunified">stcStreamSynchronizeUnified<a href="#stcstreamsynchronizeunified" class="hash-link" aria-label="Direct link to stcStreamSynchronizeUnified" title="Direct link to stcStreamSynchronizeUnified" translate="no">​</a></h5>
<p>函数描述：调用stcStreamSynchronizeUnified等待指定流上的所有操作执行结束。如果核函数执行异常退出，则输出触发异常时核函数的调用栈。</p>
<blockquote>
<p>说明：在UnifiedHS模式下，核函数需要加载四次到所有四个Cluster上，不同Cluster开始执行核函数的时间不是精确同步的。如果需要保证核函数在同一时间开始执行有效代码，用户需要自行在核函数最开始处显示地执行同步指令。同样的，如果需要保证核函数在所有Cluster同时完成，您需要自行在核函数结束前显示地执行同步指令。</p>
</blockquote>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcStreamSynchronizeUnified(stcStream_t pStream)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>pstream</td><td>输入参数</td><td>stcStream_t</td><td>流标识符，等待该流上的所有操作执行结束。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>返回值为0：成功；返回值为其他值：错误码，其中详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcstreamclean">stcStreamClean<a href="#stcstreamclean" class="hash-link" aria-label="Direct link to stcStreamClean" title="Direct link to stcStreamClean" translate="no">​</a></h5>
<p>函数描述：调用stcStreamClean停止处理流上的请求并销毁所有请求，但不会销毁流本身。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcStreamClean(stcStream_t stream)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stream</td><td>输入参数</td><td>stcStream_t</td><td>流标识符，停止处理该流的请求，并销毁所有请求。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stceventcreate">stcEventCreate<a href="#stceventcreate" class="hash-link" aria-label="Direct link to stcEventCreate" title="Direct link to stcEventCreate" translate="no">​</a></h5>
<p>函数描述：调用stcEventCreate创建一个事件。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcEventCreate(stcEvent_t *pEvent)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>pEvent</td><td>输出参数</td><td>stcEvent_t*</td><td>指向创建的事件标识符的指针。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stceventdestroy">stcEventDestroy<a href="#stceventdestroy" class="hash-link" aria-label="Direct link to stcEventDestroy" title="Direct link to stcEventDestroy" translate="no">​</a></h5>
<p>函数描述：调用stcEventDestroy销毁指定事件。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcError_t stcEventDestroy(stcEvent_t event)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>event</td><td>输入参数</td><td>stcEvent_t</td><td>待销毁事件的标识符。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stceventsynchronize">stcEventSynchronize<a href="#stceventsynchronize" class="hash-link" aria-label="Direct link to stcEventSynchronize" title="Direct link to stcEventSynchronize" translate="no">​</a></h5>
<p>函数描述：调用stcEventSynchronize等待指定事件进入完成状态。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcEventSynchronize(stcEvent_t event)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>event</td><td>输入参数</td><td>stcEvent_t</td><td>事件标识符，等待流中该事件前的所有操作执行结束后，才会将事件置为完成状态。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stceventrecord">stcEventRecord<a href="#stceventrecord" class="hash-link" aria-label="Direct link to stcEventRecord" title="Direct link to stcEventRecord" translate="no">​</a></h5>
<p>函数描述：调用stcEventRecord在指定流的当前运行点添加事件。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcEventRecord(stcEvent_t event, stcStream_t stream=0)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>event</td><td>输入参数</td><td>stcEvent_t</td><td>待添加事件的标识符。</td></tr><tr><td>stream</td><td>输入参数</td><td>stcStream_t</td><td>待添加事件的流的标识符，默认为0，代表在所有流的当前运行点添加事件。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stceventelapsedtime">stcEventElapsedTime<a href="#stceventelapsedtime" class="hash-link" aria-label="Direct link to stcEventElapsedTime" title="Direct link to stcEventElapsedTime" translate="no">​</a></h5>
<p>函数描述：调用stcEventElapsedTime获取处理两个事件间请求所消耗的时间。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcEventElapsedTime(float *ms, stcEvent_t start, stcEvent_t end)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>ms</td><td>输出参数</td><td>float*</td><td>指向所获取消耗时间的指针，消耗时间的单位为ms。</td></tr><tr><td>start</td><td>输入参数</td><td>stcEvent_t</td><td>开始事件的标识符。</td></tr><tr><td>end</td><td>输入参数</td><td>stcEvent_t</td><td>结束事件的标识符。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcstreamwaitevent">stcStreamWaitEvent<a href="#stcstreamwaitevent" class="hash-link" aria-label="Direct link to stcStreamWaitEvent" title="Direct link to stcStreamWaitEvent" translate="no">​</a></h5>
<p>函数描述：调用stcStreamWaitEvent在多流场景中建立流之间的同步关系，指定某个流需要等指定事件被置为完成状态后再开始处理请求。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcStreamWaitEvent(stcStream_t stream, stcEvent_t event)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stream</td><td>输入参数</td><td>stcStream_t</td><td>流标识符，该流在对应事件被置为完成状态后再开始处理请求。</td></tr><tr><td>event</td><td>输入参数</td><td>stcEvent_t</td><td>事件标识符。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="卡卡互联">卡卡互联<a href="#卡卡互联" class="hash-link" aria-label="Direct link to 卡卡互联" title="Direct link to 卡卡互联" translate="no">​</a></h4>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcsetp2pmap">stcSetP2PMap<a href="#stcsetp2pmap" class="hash-link" aria-label="Direct link to stcSetP2PMap" title="Direct link to stcSetP2PMap" translate="no">​</a></h5>
<p>函数描述：设置跨卡程序需要使用的板卡信息，包含板卡的数量，以及板卡的编号列表。</p>
<blockquote>
<p>说明：所有的板卡均需要设置，并且在使用前请使用stcSetDevice接口指定板卡。</p>
</blockquote>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcSetP2PMap(char *json_config);</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>*json_config</td><td>输入参数</td><td>char</td><td>设置P2P工作组需要板卡信息，包含所在主机的IP地址，板卡的虚拟和物理ID。</td></tr></tbody></table>
<p>配置信息使用json字符串，格式如下：</p>
<div class="language-json codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-json codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">{</span><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    nr_npus</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> N</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    npus</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> host</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;xxx.xxx.xxx.xxx&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> virt_npu_id</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> phys_npu_id</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> X </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> host</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;xxx.xxx.xxx.xxx&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> virt_npu_id</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> phys_npu_id</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> Y </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">               </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ...</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> host</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;xxx.xxx.xxx.xxx&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> virt_npu_id</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> N</span><span class="token number" style="color:#36acaa">-1</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> phys_npu_id</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> Z </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           </span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre></div></div>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcclearp2pmap">stcClearP2PMap<a href="#stcclearp2pmap" class="hash-link" aria-label="Direct link to stcClearP2PMap" title="Direct link to stcClearP2PMap" translate="no">​</a></h5>
<p>函数描述：清除跨卡程序的板卡信息。</p>
<blockquote>
<p>说明：所有的板卡均需要设置，并且在使用前请使用stcSetDevice接口指定板卡。</p>
</blockquote>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcClearP2PMap()</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<p>无</p>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="错误处理">错误处理<a href="#错误处理" class="hash-link" aria-label="Direct link to 错误处理" title="Direct link to 错误处理" translate="no">​</a></h4>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcgetlasterror">stcGetLastError<a href="#stcgetlasterror" class="hash-link" aria-label="Direct link to stcGetLastError" title="Direct link to stcGetLastError" translate="no">​</a></h5>
<p>函数描述：调用stcGetLastError返回一个线程调用主机端运行时接口时产生的最后一个错误，然后将结果重置为stcSuccess。如果没有错误，则返回stcSuccess。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stcError_t stcGetLastError(void)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<p>无</p>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcError_t</td><td>详细的错误类型含义，请参见<em>stcError_t</em>章节。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcgeterrorname">stcGetErrorName<a href="#stcgeterrorname" class="hash-link" aria-label="Direct link to stcGetErrorName" title="Direct link to stcGetErrorName" translate="no">​</a></h5>
<p>函数描述：调用stcGetErrorName从获取的错误码得到错误名称。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const char* stcGetErrorName (stcError_t error)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>error</td><td>输入参数</td><td>stcError_t</td><td>调用<code>stcGetLastError</code>获取到的错误码。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>const char*</td><td>指向错误名称字符串的指针，字符串以NULL结尾。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcgeterrorstring">stcGetErrorString<a href="#stcgeterrorstring" class="hash-link" aria-label="Direct link to stcGetErrorString" title="Direct link to stcGetErrorString" translate="no">​</a></h5>
<p>函数描述：调用stcGetErrorString从获取的错误码得到错误详情。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const char* stcGetErrorString (stcError_t error)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>error</td><td>输入参数</td><td>stcError_t</td><td>调用<code>stcGetLastError</code>获取到的错误码。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>const char*</td><td>指向NULL结尾的字符串。</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="数据类型">数据类型<a href="#数据类型" class="hash-link" aria-label="Direct link to 数据类型" title="Direct link to 数据类型" translate="no">​</a></h4>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stckernelparams_t">stcKernelParams_t<a href="#stckernelparams_t" class="hash-link" aria-label="Direct link to stcKernelParams_t" title="Direct link to stcKernelParams_t" translate="no">​</a></h5>
<p>数据描述：记录一个核函数的所有参数信息。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcmodule_t">stcModule_t<a href="#stcmodule_t" class="hash-link" aria-label="Direct link to stcModule_t" title="Direct link to stcModule_t" translate="no">​</a></h5>
<p>数据描述：记录一个NPC Cluster设备目标程序模块的相关信息。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcstream_t">stcStream_t<a href="#stcstream_t" class="hash-link" aria-label="Direct link to stcStream_t" title="Direct link to stcStream_t" translate="no">​</a></h5>
<p>数据描述：记录一个流的相关信息。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcevent_t">stcEvent_t<a href="#stcevent_t" class="hash-link" aria-label="Direct link to stcEvent_t" title="Direct link to stcEvent_t" translate="no">​</a></h5>
<p>数据描述：记录一个事件的相关信息。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcerror_t">stcError_t<a href="#stcerror_t" class="hash-link" aria-label="Direct link to stcError_t" title="Direct link to stcError_t" translate="no">​</a></h5>
<p>数据描述：记录调用主机端运行时接口时返回的错误。支持返回的错误类型如下所示：</p>
<table><thead><tr><th><strong>枚举成员</strong></th><th><strong>枚举值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcSuccess</td><td>0</td><td>函数调用成功，未返回错误。</td></tr><tr><td>stcErrorInvalidValue</td><td>1</td><td>一个或多个参数的取值超出了有效值范围。</td></tr><tr><td>stcErrorInvalidDevice</td><td>2</td><td>使用了无效的NPC Cluster ID。</td></tr><tr><td>stcErrorHostMemoryAllocation</td><td>3</td><td>在主机端分配内存失败。</td></tr><tr><td>stcErrorDeviceMemoryAllocation</td><td>4</td><td>在设备端分配内存失败。</td></tr><tr><td>stcErrorInvalidDevicePointer</td><td>5</td><td>使用了无效的设备端内存地址。</td></tr><tr><td>stcErrorLinkFailure</td><td>6</td><td>设备端目标程序链接失败。</td></tr><tr><td>stcErrorInvalidKernel</td><td>7</td><td>使用了无效的核函数名称。</td></tr><tr><td>stcErrorInvalidImage</td><td>8</td><td>设备端目标程序不可用。<br>说明：设备端目标程序对应fat binary，而设备端目标模块则对应具体的binary。</td></tr><tr><td>stcErrorNoImage</td><td>9</td><td>设备端目标程序不存在。</td></tr><tr><td>stcErrorInvalidModule</td><td>10</td><td>设备端目标模块不可用。<br>说明：设备端目标程序对应fat binary，而设备端目标模块则对应具体的binary。</td></tr><tr><td>stcErrorNoModule</td><td>11</td><td>设备端目标模块不存在。</td></tr><tr><td>stcErrorInvalidStream</td><td>12</td><td>流不可用。</td></tr><tr><td>stcErrorInvalidEvent</td><td>13</td><td>事件不可用。</td></tr><tr><td>stcErrorDeviceImageException</td><td>15</td><td>设备端目标程序运行时出现异常。</td></tr><tr><td>stcErrorSyscallFailure</td><td>16</td><td>主机端的系统调用失败。</td></tr><tr><td>stcErrorForkForbidden</td><td>17</td><td>父进程已调用过运行时接口，禁止子进程再次调用。</td></tr><tr><td>stcErrorInvalidCoreNum</td><td>18</td><td>使用了无效的核数量。</td></tr><tr><td>stcErrorGDBFailure</td><td>19</td><td>stc-gdb跟踪失败，无法获取调试信息。</td></tr><tr><td>stcErrorDriverMismatch</td><td>20</td><td>NPU驱动版本和NPU设备不匹配。</td></tr><tr><td>stcErrorDeviceBreakdown</td><td>21</td><td>NPU设备出现故障，无法继续使用。</td></tr><tr><td>stcErrorInvalidNpuTask</td><td>24</td><td>NPU任务不可用。</td></tr><tr><td>stcErrorInvalidImageDataSection</td><td>25</td><td>设备端目标程序包含了太多可写数据段，导致程序无法正常运行。</td></tr><tr><td>stcErrorOutOfHostMemory</td><td>27</td><td>主机端内存不足。</td></tr><tr><td>stcErrorTooManyOpenStreams</td><td>28</td><td>打开流的数量过多，已超过上限。</td></tr><tr><td>stcErrorTooManyOpenEvents</td><td>29</td><td>打开事件的数量过多，已超过上限。</td></tr><tr><td>stcErrorDriverFailure</td><td>99</td><td>NPU驱动错误。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcmemcpykind_t">stcMemcpyKind_t<a href="#stcmemcpykind_t" class="hash-link" aria-label="Direct link to stcMemcpyKind_t" title="Direct link to stcMemcpyKind_t" translate="no">​</a></h5>
<p>数据描述：设置拷贝内存操作的类型。支持设置的操作类型如下所示：</p>
<table><thead><tr><th><strong>枚举定义</strong></th><th><strong>枚举值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcMemcpyHostToHost</td><td>0</td><td>在同一台主机的不同内存段间拷贝数据。</td></tr><tr><td>stcMemcpyHostToDevice</td><td>1</td><td>从主机端向设备端拷贝数据。</td></tr><tr><td>stcMemcpyDeviceToHost</td><td>2</td><td>从设备端向主机端拷贝数据。</td></tr><tr><td>stcMemcpyP2P</td><td>4</td><td>从一台主机向另外一台主机拷贝数据。</td></tr><tr><td>stcMemcpyMax</td><td>5</td><td>用于检查传入参数中的种类是否合法。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stcdeviceattr_t">stcDeviceAttr_t<a href="#stcdeviceattr_t" class="hash-link" aria-label="Direct link to stcDeviceAttr_t" title="Direct link to stcDeviceAttr_t" translate="no">​</a></h5>
<p>数据描述：记录NPU设备的属性。支持查看的属性如下所示：</p>
<table><thead><tr><th><strong>枚举定义</strong></th><th><strong>枚举值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcDevAttrChipHWVersion</td><td>0</td><td>NPU硬件版本。</td></tr><tr><td>stcDevAttrBoardHWVersion</td><td>1</td><td>板卡硬件版本。</td></tr><tr><td>stcDevAttrClusterCount</td><td>2</td><td>NPC Cluster的数量。</td></tr><tr><td>stcDevAttrNPCPerCluster</td><td>3</td><td>每个NPC Cluster包含的NPC数量。</td></tr><tr><td>stcDevAttrSharedmemPerCluster</td><td>4</td><td>每个NPC Cluster中共享内存的大小。</td></tr><tr><td>stcDevAttrGlobalmemPerCluster</td><td>5</td><td>每个NPC Cluster中全局内存的大小。</td></tr><tr><td>stcDevAttrConcurrentKernels</td><td>6</td><td>每个NPC Cluster可以并行执行的核函数的数量。</td></tr><tr><td>stcDevAttrPciBusId</td><td>7</td><td>PCIe总线的ID。</td></tr><tr><td>stcDevAttrPciDeviceId</td><td>8</td><td>PCIe设备的ID，即希姆计算板卡的ID，例如STCP920的为0100。</td></tr><tr><td>stcDevAttrFirmwareVersion</td><td>9</td><td>设备端固件的版本。</td></tr><tr><td>stcDevAttrDriverVersion</td><td>10</td><td>主机端安装的设备驱动版本。</td></tr><tr><td>stcDevAttrCount</td><td>11</td><td>支持查看的属性数量，即本表格中除stcDevAttrCount外枚举定义的数量。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stckernelflag_t">stcKernelFlag_t<a href="#stckernelflag_t" class="hash-link" aria-label="Direct link to stcKernelFlag_t" title="Direct link to stcKernelFlag_t" translate="no">​</a></h5>
<p>数据描述：设置核函数的运行标志。支持设置的运行标志如下所示：</p>
<table><thead><tr><th><strong>枚举定义</strong></th><th><strong>枚举值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>stcKernelFlagNone</td><td>0</td><td>NPC执行核函数前后均处理DCache，可以视为无运行标志。</td></tr><tr><td>stcKernelFlagInputDataBypassDcache</td><td>1</td><td>NPC执行核函数前，不需要处理DCache。</td></tr><tr><td>stcKernelFlagOutputDataBypassDache</td><td>2</td><td>NPC执行核函数后，不需要处理DCache。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stckerneldata_t">stcKernelData_t<a href="#stckerneldata_t" class="hash-link" aria-label="Direct link to stcKernelData_t" title="Direct link to stcKernelData_t" translate="no">​</a></h5>
<p>数据描述：核函数输入输出对应的主机端数据区的属性。包含的成员变量如下所示：</p>
<table><thead><tr><th><strong>成员变量</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>data</td><td>数据区的地址。</td></tr><tr><td>size</td><td>数据区的大小。</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="环境变量">环境变量<a href="#环境变量" class="hash-link" aria-label="Direct link to 环境变量" title="Direct link to 环境变量" translate="no">​</a></h4>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="stc_set_devices">STC_SET_DEVICES<a href="#stc_set_devices" class="hash-link" aria-label="Direct link to STC_SET_DEVICES" title="Direct link to STC_SET_DEVICES" translate="no">​</a></h5>
<p>数据描述：运行时修改<code>stcSetDevice</code>的执行结果，支持同时设置多个NPC Cluster ID，以半角逗号分隔即可。每个设置的索引为原NPC Cluster ID，设置的值为新NPC Cluster ID。示例如下：</p>
<table><thead><tr><th><strong>设置</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>export STC_SET_DEVICES=2</td><td>设置<code>STC_SET_DEVICES</code>为2后：默认使用NPC Cluster 2。执行<code>stcSetDevice</code>的起始NPC Cluster ID为2。例如，stcSetDevice(0)代表使用NPC Cluster ID为2，stcSetDevice(1)代表使用NPC Cluster ID为3。</td></tr><tr><td>export STC_SET_DEVICES=2, 3</td><td>设置<code>STC_SET_DEVICES</code>为2和3后：默认使用NPC Cluster 2，可以使用NPC Cluster 2和NPC Cluster 3。执行<code>stcSetDevice</code>的起始NPC Cluster ID为2。例如，stcSetDevice(0)代表使用NPC Cluster 2，stcSetDevice(1)代表使用NPC Cluster 3。</td></tr></tbody></table>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="hpe设备端运行时api">HPE设备端运行时API<a href="#hpe设备端运行时api" class="hash-link" aria-label="Direct link to HPE设备端运行时API" title="Direct link to HPE设备端运行时API" translate="no">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="调用要求-1">调用要求<a href="#调用要求-1" class="hash-link" aria-label="Direct link to 调用要求" title="Direct link to 调用要求" translate="no">​</a></h3>
<p>调用HPE设备端运行时API时，请确保：</p>
<ul>
<li>
<p>已安装HPE。具体操作，请参见<a href="https://docs.streamcomputing.com/_/sharing/vSxLMI20nalGphdpXdEVoDg6JkUcfEkT?next=/zh/latest/" target="_blank" rel="noopener noreferrer">STCRP安装指南</a>。</p>
</li>
<li>
<p>在代码文件中导入所需的头文件，包括但不限于：</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;npurt.h&gt;</span><br></span></code></pre></div></div>
</li>
</ul>
<blockquote>
<p>说明：系统的HPE异构编程介绍，请参见<a href="https://docs.streamcomputing.com/_/sharing/vSxLMI20nalGphdpXdEVoDg6JkUcfEkT?next=/zh/latest/" target="_blank" rel="noopener noreferrer">STCRP开发指南</a>，安装HPE后自带的异构编程示例，请参见<a href="https://docs.streamcomputing.com/_/sharing/vSxLMI20nalGphdpXdEVoDg6JkUcfEkT?next=/zh/latest/" target="_blank" rel="noopener noreferrer">HPE使用指南</a>。</p>
</blockquote>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="接口说明-1">接口说明<a href="#接口说明-1" class="hash-link" aria-label="Direct link to 接口说明" title="Direct link to 接口说明" translate="no">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="exit">exit<a href="#exit" class="hash-link" aria-label="Direct link to exit" title="Direct link to exit" translate="no">​</a></h4>
<p>函数描述：调用exit退出核函数并返回您指定的退出码。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">__device__ void exit(int exit_code)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>exit_code</td><td>输入参数</td><td>int</td><td>您自行定义的退出码。</td></tr></tbody></table>
<p>函数返回值：</p>
<p>无</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="abort">abort<a href="#abort" class="hash-link" aria-label="Direct link to abort" title="Direct link to abort" translate="no">​</a></h4>
<p>函数描述：调用abort退出核函数并返回退出码128。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">__device__ void abort()</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<p>无</p>
<p>函数返回值：</p>
<p>无</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="assert">assert<a href="#assert" class="hash-link" aria-label="Direct link to assert" title="Direct link to assert" translate="no">​</a></h4>
<p>函数描述：调用assert验证指定的条件，在未满足断言时，退出核函数并返回退出码128。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">__device__ void assert(int exp)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>exp</td><td>输入参数</td><td>int</td><td>指定的条件。如果未满足断言，则值为0，退出核函数并返回错误码128。</td></tr></tbody></table>
<p>函数返回值：</p>
<p>无</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="memcpy">memcpy<a href="#memcpy" class="hash-link" aria-label="Direct link to memcpy" title="Direct link to memcpy" translate="no">​</a></h4>
<p>函数描述：调用memcpy在设备端拷贝内存，支持以指定内存大小或信息格式（通过cpy_config_t描述）的形式拷贝。该函数支持以下拷贝方向：</p>
<ul>
<li>本地内存之间、共享内存之间、全局内存（0GiB ~ 4GiB）之间</li>
<li>本地内存与共享内存之间</li>
<li>本地内存和全局内存（0GiB ~ 3GiB）之间</li>
<li>共享内存与全局内存（0GiB ~ 4GiB）之间</li>
</ul>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">__device__ int memcpy(void* dest, void* src, int len)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">__device__ int memcpy(void* dest, void* src, cpy_config_t info)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>dest</td><td>输入参数</td><td>void*</td><td>拷贝操作的目的地址，向该指针指向的内存写入数据。</td></tr><tr><td>src</td><td>输入参数</td><td>void*</td><td>拷贝操作的源地址，从该指针指向的内存读取数据。</td></tr><tr><td>len</td><td>输入参数</td><td>int</td><td>待拷贝内存的大小，单位为字节。</td></tr><tr><td>info</td><td>输入参数</td><td>cpy_config_t</td><td>待拷贝内存的信息格式的描述，详细的信息格式说明，请参见<em>cpy_config_t</em>章节。</td></tr></tbody></table>
<blockquote>
<p>注意：建议您使用stcMalloc或stcMallocHigh分配内存。如果dest和src对应的内存不是通过stcMalloc或stcMallocHigh分配，则必须在传入dest和src前自行添加对齐属性，保证地址满足64字节对齐。添加对齐属性的方法：定义变量时，在原语句前添加关键字<code>__attribute__((aligned(64)))</code>，例如<code>__local__ __attribute__((aligned(64))) int local_data[NCORE]</code>。</p>
</blockquote>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>int</td><td>详细的错误类型含义，请参见<em>npurtError_t</em>章节。</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="get_npu_idx">get_npu_idx<a href="#get_npu_idx" class="hash-link" aria-label="Direct link to get_npu_idx" title="Direct link to get_npu_idx" translate="no">​</a></h4>
<p>函数描述：获取调用者所在NPU卡的ID。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int get_npu_idx()</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<p>无</p>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>int</td><td>NPU卡的逻辑ID，范围：0~（NPU卡数量-1）。</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="get_npu_nr">get_npu_nr<a href="#get_npu_nr" class="hash-link" aria-label="Direct link to get_npu_nr" title="Direct link to get_npu_nr" translate="no">​</a></h4>
<p>函数描述：查询程序可以使用的NPU卡数量。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int get_npu_nr()</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<p>无</p>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>int</td><td>返回值为0：非跨卡程序<br>返回值为其他数值：跨卡程序使用的NPU卡数量</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="memcpy_p2p">memcpy_p2p<a href="#memcpy_p2p" class="hash-link" aria-label="Direct link to memcpy_p2p" title="Direct link to memcpy_p2p" translate="no">​</a></h4>
<p>函数描述：在本地发起一个向远端NPU DDR的数据传输，将本NPU卡的数据传输到远端NPU卡。当远端flag_addr为非0时，可以同时向该远端地址写入一个4字节的flag值。</p>
<p>由于卡卡互联的功能性与主机系统的配置（包括BIOS设置和Linux引导参数）有关系，所以通常情况下，完全关闭CPU的虚拟化功能即可支持P2P传输。若需在开启CPU的虚拟化功能的情况下使用P2P功能，则需设置<code>intel_iommu=on</code>（或<code>amd_iommu=on</code>）和<code>iommu=pt</code>。有时，也可能需要升级主机的BIOS（或CPU Microcode）才可使能P2P功能。</p>
<blockquote>
<p>说明：每个NPC均可发起P2P传输任务，传输任务是异步执行的。在该任务完成前，该NPC不能发起另一个任务；此时如果再次调用该接口，会等待上次一任务完成后才能完成新任务提交。</p>
</blockquote>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int memcpy_p2p(uint64_t dst, uint64_t src, uint64_t len, int dst_npu_idx, uint64_t flag_addr, uint32_t flag)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>dst</td><td>输入参数</td><td>uint64_t</td><td>远端NPU卡的目的地址，必须4字节对齐。</td></tr><tr><td>src</td><td>输入参数</td><td>uint64_t</td><td>本地NPU卡的源地址，必须4字节对齐。</td></tr><tr><td>len</td><td>输入参数</td><td>uint64_t</td><td>传输的数据长度，必须为4字节倍数。当len为零时，不传输数据。</td></tr><tr><td>dst_npu_idx</td><td>输入参数</td><td>int</td><td>远端NPU卡的ID。</td></tr><tr><td>flag_addr</td><td>输入参数</td><td>uint64_t</td><td>远端NPU卡的flag地址。当flag_addr为零时，不传输flag的值。</td></tr><tr><td>flag</td><td>输入参数</td><td>uint32_t</td><td>flag的值。</td></tr></tbody></table>
<blockquote>
<p>说明：当len和flag_addr都为零时，为无效传输，系统报错。</p>
</blockquote>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>int</td><td>返回值为0：任务创建成功（始终成功）。</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="memcpy_p2p_wait">memcpy_p2p_wait<a href="#memcpy_p2p_wait" class="hash-link" aria-label="Direct link to memcpy_p2p_wait" title="Direct link to memcpy_p2p_wait" translate="no">​</a></h4>
<p>函数描述：等待本地发起的p2p传输完成。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void memcpy_p2p_wait()</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<p>无</p>
<p>函数返回值：</p>
<p>无</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="wait_flag">wait_flag<a href="#wait_flag" class="hash-link" aria-label="Direct link to wait_flag" title="Direct link to wait_flag" translate="no">​</a></h4>
<p>函数描述：等待远端NPU卡上的地址值被修改为预期标识值，用于确认远端发起的P2P传输是否完成。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void wait_flag(uint32_t addr, uint32_t flag)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>addr</td><td>输入参数</td><td>uint32_t</td><td>远端NPU卡的目的地址。</td></tr><tr><td>flag</td><td>输入参数</td><td>uint32_t</td><td>预期标识值。</td></tr></tbody></table>
<p>函数返回值：</p>
<p>无</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="数据类型-1">数据类型<a href="#数据类型-1" class="hash-link" aria-label="Direct link to 数据类型" title="Direct link to 数据类型" translate="no">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="npurterror_t">npurtError_t<a href="#npurterror_t" class="hash-link" aria-label="Direct link to npurtError_t" title="Direct link to npurtError_t" translate="no">​</a></h4>
<p>数据描述：记录调用设备端运行时接口时返回的错误。支持返回的错误类型如下所示：</p>
<table><thead><tr><th><strong>枚举定义</strong></th><th><strong>枚举值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>npurtSuccess</td><td>0</td><td>函数调用成功，未返回错误。</td></tr><tr><td>npurtErrorSysdmaInvalidDmaID</td><td>1</td><td>使用SysDMA在共享内存和全局内存间传输数据时，指定了无效的DMA控制器ID。</td></tr><tr><td>npurtErrorSysdmaInvalidChannelID</td><td>2</td><td>指定了无效的DMA通道ID。</td></tr><tr><td>npurtErrorSysdmaInvalidDataRow</td><td>3</td><td>指定了无效的数据行。</td></tr><tr><td>npurtErrorSysdmaInvalidDataCol</td><td>4</td><td>指定了无效的数据列。</td></tr><tr><td>npurtErrorSysdmaInvalidDataStride</td><td>5</td><td>指定了无效的数据Stride。</td></tr><tr><td>npurtErrorSysdmaInvalidDataSize</td><td>6</td><td>指定了无效的数据大小。</td></tr><tr><td>npurtErrorSysdmaInvalidState</td><td>7</td><td>无效的DMA状态。</td></tr><tr><td>npurtErrorSysdmaReqFull</td><td>8</td><td>DMA请求队列已满，无法处理更多请求。</td></tr><tr><td>npurtErrorSysdmaInvalidAddress</td><td>9</td><td>指定了无效的地址。</td></tr><tr><td>npurtErrorSysdmaInvalidXferType</td><td>10</td><td>指定了无效的传输类型。</td></tr><tr><td>npurtErrorSysdmaBusy</td><td>11</td><td>DMA正在使用中，无法执行其他任务。</td></tr><tr><td>npurtErrorSysdmaXferFailure</td><td>12</td><td>数据传输失败。</td></tr><tr><td>npurtMemcpyIncompatibleParamLen</td><td>13</td><td>拷贝内存时，指定了无法识别的参数。</td></tr><tr><td>npurtErrorMemcpyInvalidAddress</td><td>14</td><td>指定了无效的地址。</td></tr><tr><td>npurtErrorMemcpyInvalidConfigRows</td><td>15</td><td>指定了无效的数据行。</td></tr><tr><td>npurtErrorMemcpyInvalidConfigCols</td><td>16</td><td>指定了无效的数据列。</td></tr><tr><td>npurtErrorMemcpyInvalidDataStrides</td><td>17</td><td>指定了无效的数据Stride。</td></tr><tr><td>npurtErrorMemcpyInvalidConfigDtype</td><td>18</td><td>指定了无效的数据类型。</td></tr><tr><td>npurtErrorMemcpyInvalidConfigDestcore</td><td>19</td><td>指定了无效的目标NPC。</td></tr><tr><td>npurtErrorMemcpyInvalidDataSize</td><td>20</td><td>指定了无效的数据大小。</td></tr><tr><td>npurtErrorMemcpyOverflowBoundary</td><td>21</td><td>超过了源或目的地址空间。</td></tr><tr><td>npurtErrorMemcpyGlbmem32Unaligned</td><td>22</td><td>发现源或目的地址没有32字节对齐。</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="cpy_config_t">cpy_config_t<a href="#cpy_config_t" class="hash-link" aria-label="Direct link to cpy_config_t" title="Direct link to cpy_config_t" translate="no">​</a></h4>
<p>数据描述：待拷贝内存的信息格式。包含的成员变量如下：</p>
<table><thead><tr><th><strong>成员变量</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>rows</td><td>待拷贝数据的行数。</td></tr><tr><td>cols</td><td>待拷贝数据的列数。</td></tr><tr><td>stride_cols</td><td>拷贝数据时使用的列数Stride。</td></tr><tr><td>dtype</td><td>待拷贝数据的类型。详细的数据类型定义，请参见<em>cpy_dtype_t</em>章节。</td></tr><tr><td>dest_core</td><td>拷贝数据时NPC Cluster内目标NPC的标识符，该参数只适用于在不同NPC的本地内存间传输数据。<br>说明：目前<code>memcpy</code>仅支持在同一NPC Cluster内拷贝。</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="cpy_dtype_t">cpy_dtype_t<a href="#cpy_dtype_t" class="hash-link" aria-label="Direct link to cpy_dtype_t" title="Direct link to cpy_dtype_t" translate="no">​</a></h4>
<p>数据描述：待拷贝数据的类型。支持的数据类型如下所示：</p>
<table><thead><tr><th><strong>枚举定义</strong></th><th><strong>枚举值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>DTYPE_BYTE_1</td><td>0</td><td>每个数据元素占一个字节大小。</td></tr><tr><td>DTYPE_BYTE_2</td><td>1</td><td>每个数据元素占两个字节大小。</td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="变量">变量<a href="#变量" class="hash-link" aria-label="Direct link to 变量" title="Direct link to 变量" translate="no">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="coreid">CoreID<a href="#coreid" class="hash-link" aria-label="Direct link to CoreID" title="Direct link to CoreID" translate="no">​</a></h4>
<p>描述：获取NPC在NPC Cluster内的标识符，例如STCP920芯片中CoreID的范围为0 ~ 7。</p>
<p>类型：整型只读</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="corenum">CoreNum<a href="#corenum" class="hash-link" aria-label="Direct link to CoreNum" title="Direct link to CoreNum" translate="no">​</a></h4>
<p>描述：获取运行核函数时所使用NPC的个数。</p>
<p>类型：整型只读</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="stcpti性能数据采集api">STCPTI性能数据采集API<a href="#stcpti性能数据采集api" class="hash-link" aria-label="Direct link to STCPTI性能数据采集API" title="Direct link to STCPTI性能数据采集API" translate="no">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="调用要求-2">调用要求<a href="#调用要求-2" class="hash-link" aria-label="Direct link to 调用要求" title="Direct link to 调用要求" translate="no">​</a></h3>
<p>调用STCPTI性能数据采集API时，请确保：</p>
<ul>
<li>
<p>已安装HPE。具体操作，请参见<a href="https://docs.streamcomputing.com/_/sharing/vSxLMI20nalGphdpXdEVoDg6JkUcfEkT?next=/zh/latest/" target="_blank" rel="noopener noreferrer">STCRP安装指南</a>。</p>
</li>
<li>
<p>在代码文件中导入所需的头文件，包括但不限于：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;stcpti.h&gt;</span><br></span></code></pre></div></div>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="接口说明-2">接口说明<a href="#接口说明-2" class="hash-link" aria-label="Direct link to 接口说明" title="Direct link to 接口说明" translate="no">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="stcptikernelcontextcreate">stcptiKernelContextCreate<a href="#stcptikernelcontextcreate" class="hash-link" aria-label="Direct link to stcptiKernelContextCreate" title="Direct link to stcptiKernelContextCreate" translate="no">​</a></h4>
<p>函数描述：为当前进程创建核函数性能数据采集的上下文。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">__host__ stcProfilerResult_t stcptiKernelContextCreate()</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<p>None</p>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>stcProfilerResult_t</td><td>详细的数据类型描述，请参见<em>stcProfilerResult_t</em>章节。</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="stcptikernelcontextrelease">stcptiKernelContextRelease<a href="#stcptikernelcontextrelease" class="hash-link" aria-label="Direct link to stcptiKernelContextRelease" title="Direct link to stcptiKernelContextRelease" translate="no">​</a></h4>
<p>函数描述：释放当前进程的核函数性能数据采集的上下文。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">__host__ stcProfilerResult_t stcptiKernelContextRelease()</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<p>None</p>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>stcProfilerResult_t</td><td>详细的数据类型描述，请参见<em>stcProfilerResult_t</em>章节。</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="stcptikernelcontextreleaseall">stcptiKernelContextReleaseAll<a href="#stcptikernelcontextreleaseall" class="hash-link" aria-label="Direct link to stcptiKernelContextReleaseAll" title="Direct link to stcptiKernelContextReleaseAll" translate="no">​</a></h4>
<p>函数描述：释放所有进程的核函数性能数据采集的上下文。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">__host__ stcProfilerResult_t stcptiKernelContextReleaseAll()</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<p>None</p>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>stcProfilerResult_t</td><td>详细的数据类型描述，请参见<em>stcProfilerResult_t</em>章节。</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="stcptikernelenable">stcptiKernelEnable<a href="#stcptikernelenable" class="hash-link" aria-label="Direct link to stcptiKernelEnable" title="Direct link to stcptiKernelEnable" translate="no">​</a></h4>
<p>函数描述：启动当前进程的性能数据采集。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">__host__ stcProfilerResult_t stcptiKernelEnable()</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<p>None</p>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>stcProfilerResult_t</td><td>详细的数据类型描述，请参见<em>stcProfilerResult_t</em>章节。</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="stcptikerneldisable">stcptiKernelDisable<a href="#stcptikerneldisable" class="hash-link" aria-label="Direct link to stcptiKernelDisable" title="Direct link to stcptiKernelDisable" translate="no">​</a></h4>
<p>函数描述：停止当前进程的性能数据采集。</p>
<p>函数类型：同步函数</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">__host__ stcProfilerResult_t stcptiKernelDisable()</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<p>None</p>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>stcProfilerResult_t</td><td>详细的数据类型描述，请参见<em>stcProfilerResult_t</em>章节。</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="stcptikernelgetperfdatas">stcptiKernelGetPerfDatas<a href="#stcptikernelgetperfdatas" class="hash-link" aria-label="Direct link to stcptiKernelGetPerfDatas" title="Direct link to stcptiKernelGetPerfDatas" translate="no">​</a></h4>
<p>函数描述：获取当前进程的性能数据采集结果。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">__host__ stcProfilerResult_t stcptiKernelGetPerfDatas(struct STCpti_PerfDatas *perf_data)</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>perf_data</td><td>输出参数</td><td>STCpti_PerfDatas</td><td>用于返回所有核函数在所有NPC上的性能数据。详细的数据类型描述，请参见<em>STCpti_PerfDatas</em>章节。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>stcProfilerResult_t</td><td>详细的数据类型描述，请参见<em>stcProfilerResult_t</em>章节。</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="stcptigeteventnamefromid">stcptiGetEventNameFromID<a href="#stcptigeteventnamefromid" class="hash-link" aria-label="Direct link to stcptiGetEventNameFromID" title="Direct link to stcptiGetEventNameFromID" translate="no">​</a></h4>
<p>函数描述：获取指定性能数据采集事件的值对应的名称。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">__host__ stcProfilerResult_t stcptiGetEventNameFromID(int e, const char **eventName);</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>参数名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>e</td><td>输入参数</td><td>int</td><td>待查询的性能数据采集事件的值。</td></tr><tr><td>eventName</td><td>输出参数</td><td>const char **</td><td>查询到的event名称。event的值和名称的对应关系，请参见<em>stcPtiEventID_t</em>章节。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>stcProfilerResult_t</td><td>详细的数据类型描述，请参见<em>stcProfilerResult_t</em>章节。</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="stcptikernelismcucycle32ovf">stcptiKernelIsMcuCycle32Ovf<a href="#stcptikernelismcucycle32ovf" class="hash-link" aria-label="Direct link to stcptiKernelIsMcuCycle32Ovf" title="Direct link to stcptiKernelIsMcuCycle32Ovf" translate="no">​</a></h4>
<p>函数描述：判断32位的MCU Cycle寄存器是否溢出。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">__host__ bool stcptiKernelIsMcuCycle32Ovf(struct STCpti_KernelNpcPerfData kernel_perf_data);</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>kernel_perf_data</td><td>输入参数</td><td>STCpti_KernelNpcPerfData</td><td>需要查询的NPC性能数据。详细的数据类型描述，请参见<em>STCpti_PerfDatas</em>章节。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>bool</td><td>1：溢出。 <br>0：未溢出。</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="stcptikernelgetmcucycle64">stcptiKernelGetMcuCycle64<a href="#stcptikernelgetmcucycle64" class="hash-link" aria-label="Direct link to stcptiKernelGetMcuCycle64" title="Direct link to stcptiKernelGetMcuCycle64" translate="no">​</a></h4>
<p>函数描述：获取64位的MCU cycle数值。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">__host__ uint64_t stcptiKernelGetMcuCycle64(struct STCpti_KernelNpcPerfData kernel_perf_data);</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>kernel_perf_data</td><td>输入参数</td><td>STCpti_KernelNpcPerfData</td><td>需要查询的NPC性能数据。详细的数据类型描述，请参见<em>STCpti_PerfDatas</em>章节。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>uint64_t</td><td>获取到的MCU cycle数值。</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="stcptikernelismcucycle64ovf">stcptiKernelIsMcuCycle64Ovf<a href="#stcptikernelismcucycle64ovf" class="hash-link" aria-label="Direct link to stcptiKernelIsMcuCycle64Ovf" title="Direct link to stcptiKernelIsMcuCycle64Ovf" translate="no">​</a></h4>
<p>函数描述：判断64位的MCU Cycle寄存器是否溢出。</p>
<p>函数类型：同步函数</p>
<p>函数定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">__host__ bool stcptiKernelIsMcuCycle64Ovf(struct STCpti_KernelNpcPerfData kernel_perf_data);</span><br></span></code></pre></div></div>
<p>函数参数：</p>
<table><thead><tr><th><strong>参数名称</strong></th><th><strong>输入/输出</strong></th><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>kernel_perf_data</td><td>输入参数</td><td>STCpti_KernelNpcPerfData</td><td>需要查询的NPC性能数据。详细的数据类型描述，请参见<em>STCpti_PerfDatas</em>章节。</td></tr></tbody></table>
<p>函数返回值：</p>
<table><thead><tr><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>bool</td><td>1：溢出。 <br>0：未溢出。</td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="数据类型-2">数据类型<a href="#数据类型-2" class="hash-link" aria-label="Direct link to 数据类型" title="Direct link to 数据类型" translate="no">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="stcpti_perfdatas">STCpti_PerfDatas<a href="#stcpti_perfdatas" class="hash-link" aria-label="Direct link to STCpti_PerfDatas" title="Direct link to STCpti_PerfDatas" translate="no">​</a></h4>
<p>STCpti_PerfDatas结构体的属性如下：</p>
<table><thead><tr><th><strong>属性名称</strong></th><th><strong>属性类型</strong></th><th><strong>属性描述</strong></th></tr></thead><tbody><tr><td>pKernelPerfDatas</td><td>STCpti_KernelPerfDatas *</td><td>STCpti_KernelPerfDatas数组的指针，保存了所有核函数的性能数据。该数组的每个元素对应一个核函数中采集到的性能数据，包括在每个NPC上的性能数据和sysDMA相关的性能数据。</td></tr><tr><td>kernelPerfDataSize</td><td>size_t</td><td>STCpti_KernelPerfDatas数组的大小。</td></tr></tbody></table>
<p>其中，STCpti_KernelPerfDatas结构体的属性如下：</p>
<table><thead><tr><th><strong>属性名称</strong></th><th><strong>属性类型</strong></th><th><strong>属性描述</strong></th></tr></thead><tbody><tr><td>pKernelName</td><td>char *</td><td>指向Kernel名称的指针。</td></tr><tr><td>arrKernelNpcPerfData</td><td>STCpti_KernelNpcPerfData *</td><td>STCpti_KernelNpcPerfData数组的指针，保存了单个核函数使用NPC的性能数据。该数组的每个元素对应一个NPC上的性能数据，包括MCU指令、VME指令、MME指令、MTE指令等的性能信息，例如cycle数等。</td></tr><tr><td>kernelNpcPerfDataSize</td><td>size_t</td><td>STCpti_KernelNpcPerfData数组的大小。</td></tr><tr><td>kernelDmaPerfData</td><td>STCpti_KernelDmaPerfData</td><td>保存了sysDMA相关的性能数据，例如LLB、DDR之间搬运的数据量和带宽。</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="stcprofilerresult_t">stcProfilerResult_t<a href="#stcprofilerresult_t" class="hash-link" aria-label="Direct link to stcProfilerResult_t" title="Direct link to stcProfilerResult_t" translate="no">​</a></h4>
<p>数据描述：记录了调用STCPTI接口的结果。支持的结果类型如下：</p>
<table><thead><tr><th><strong>枚举成员</strong></th><th><strong>枚举值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>STC_PROFILER_ERROR</td><td>-1</td><td>接口调用失败。</td></tr><tr><td>STC_PROFILER_SUCCESS</td><td>0</td><td>接口调用成功。</td></tr><tr><td>STC_PROFILER_ERROR_INVALID_ARGU</td><td>1</td><td>调用接口时传入了无效的参数。</td></tr><tr><td>STC_PROFILER_ERROR_UNKNOW</td><td>2</td><td>调用接口时产生了未知的错误。</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="stcptieventid_t">stcPtiEventID_t<a href="#stcptieventid_t" class="hash-link" aria-label="Direct link to stcPtiEventID_t" title="Direct link to stcPtiEventID_t" translate="no">​</a></h4>
<p>数据描述：记录了性能数据采集事件的类型。支持的类型如下：</p>
<table><thead><tr><th><strong>枚举成员</strong></th><th><strong>枚举值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>STC_PTI_EVENT_ID_MCU_CYCLE</td><td>0</td><td>MCU指令耗费的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_VME_CYCLE</td><td>1</td><td>自定义向量运算指令耗费的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_MME_CYCLE</td><td>2</td><td>MME指令耗费的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_VEC_CYCLE</td><td>3</td><td>RISC-V原生向量运算指令耗费的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_SYN_CYCLE</td><td>4</td><td>SYNC指令耗费的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_MTE_TOTAL_CYCLE</td><td>5</td><td>所有类型MTE指令耗费的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_VME_INST</td><td>6</td><td>自定义向量运算指令的数量。</td></tr><tr><td>STC_PTI_EVENT_ID_MME_INST</td><td>7</td><td>MME指令的数量。</td></tr><tr><td>STC_PTI_EVENT_ID_VEC_INST</td><td>8</td><td>RISC-V原生向量运算指令的数量。</td></tr><tr><td>STC_PTI_EVENT_ID_SYN_INST</td><td>9</td><td>SYNC指令的数量。</td></tr><tr><td>STC_PTI_EVENT_ID_MTE_PLD_INST</td><td>10</td><td>MTE pld指令的数量。</td></tr><tr><td>STC_PTI_EVENT_ID_MTE_ICMOV_INST</td><td>11</td><td>MTE icmov指令的数量。</td></tr><tr><td>STC_PTI_EVENT_ID_MTE_MOV_INST</td><td>12</td><td>MTE mov指令的数量。</td></tr><tr><td>STC_PTI_EVENT_ID_PAL_VME_MME_CYCLE</td><td>13</td><td>并行执行VME、MME指令耗费的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_PAL_MTE_MME_CYCLE</td><td>14</td><td>并行执行MTE、MME指令耗费的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_PAL_VME_MTE_CYCLE</td><td>15</td><td>并行执行VME、MTE指令耗费的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_PAL_TOTAL_CYCLE</td><td>16</td><td>并行执行VME、MME、MTE指令耗费的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_MTE_ICMOV_CYCLE</td><td>17</td><td>MTE icmov指令耗费的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_MTE_L12LLB_CYCLE</td><td>18</td><td>从L1向LLB搬运数据耗费的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_MTE_LLB2L1_CYCLE</td><td>19</td><td>从LLB向L1搬运数据耗费的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_MTE_PLD_CYCLE</td><td>20</td><td>MTE pld指令耗费的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_MTE_PLD_BYTE</td><td>21</td><td>通过MTE pld指令搬运的数据量，单位为字节。</td></tr><tr><td>STC_PTI_EVENT_ID_MTE_L12LLB_BYTE</td><td>22</td><td>从L1向LLB搬运的数据量，单位为字节。</td></tr><tr><td>STC_PTI_EVENT_ID_MTE_LLB2L1_BYTE</td><td>23</td><td>从LLB向L1搬运的数据量，单位为字节。</td></tr><tr><td>STC_PTI_EVENT_ID_MTE_ICMOV_BYTE</td><td>24</td><td>通过MTE icmov指令搬运的数据量，单位为字节。</td></tr><tr><td>STC_PTI_EVENT_ID_SYN_WAIT_CYCLE</td><td>25</td><td>开始SYNC后NPC Cluster内所有Core完成运算所等待的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_VEC_SLOT_WAIT_CYCLE</td><td>26</td><td>向量运算指令从接收到执行所等待的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_MME_SLOT_WAIT_CYCLE</td><td>27</td><td>MME指令从接收到执行所等待的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_MTE_SLOT_WAIT_CYCLE</td><td>28</td><td>MTE指令从接收到执行所等待的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_MIF_L1_CONFLICT_CYCLE</td><td>29</td><td>通过MIF（Memory Interface）访问L1时产生冲突的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_MIF_IM_CONFLICT_CYCLE</td><td>30</td><td>通过MIF访问IM时产生冲突的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_MCU_EVENT3_TYPE_CNT</td><td>31</td><td>可配置寄存器。</td></tr><tr><td>STC_PTI_EVENT_ID_MCU_EVENT4_TYPE_CNT</td><td>32</td><td>可配置寄存器。</td></tr><tr><td>STC_PTI_EVENT_ID_MCU_EVENT5_TYPE_CNT</td><td>33</td><td>可配置寄存器。</td></tr><tr><td>STC_PTI_EVENT_ID_MCU_EVENT6_TYPE_CNT</td><td>34</td><td>可配置寄存器。</td></tr><tr><td>STC_PTI_EVENT_ID_MCU_EVENT6H_TYPE_CNT</td><td>35</td><td>STC_PTI_EVENT_ID_MCU_EVENT6_TYPE_CNT的高32位。</td></tr><tr><td>STC_PTI_EVENT_ID_MCU_MCOUNTER_OVERFLOW</td><td>36</td><td>判断性能数据采集事件的计数是否溢出。</td></tr><tr><td>STC_PTI_EVENT_ID_SYSDMA0_DMA_ID</td><td>37</td><td>DMA控制器0的ID。</td></tr><tr><td>STC_PTI_EVENT_ID_SYSDMA0_LLB_CONFLICT_CYCLE</td><td>38</td><td>通过DMA控制器0访问LLB时产生冲突的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_SYSDMA0_DMA_C0_CYCLE0</td><td>39</td><td>DMA控制器0上Channel 0最近一次数据传输耗费的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_SYSDMA0_DMA_C0_CYCLE1</td><td>40</td><td>DMA控制器0上Channel 0所有数据传输耗费的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_SYSDMA0_DMA_C0_BYTE</td><td>41</td><td>DMA控制器0上Channel 0传输的数据量，单位为字节。</td></tr><tr><td>STC_PTI_EVENT_ID_SYSDMA0_DMA_C1_CYCLE0</td><td>42</td><td>DMA控制器0上Channel 1最近一次数据传输耗费的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_SYSDMA0_DMA_C1_CYCLE1</td><td>43</td><td>DMA控制器0上Channel 1所有数据传输耗费的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_SYSDMA0_DMA_C1_BYTE</td><td>44</td><td>DMA控制器0上Channel 0传输的数据量，单位为字节。</td></tr><tr><td>STC_PTI_EVENT_ID_SYSDMA1_DMA_ID</td><td>45</td><td>DMA控制器1的ID。</td></tr><tr><td>STC_PTI_EVENT_ID_SYSDMA1_LLB_CONFLICT_CYCLE</td><td>46</td><td>通过DMA控制器1访问LLB时产生冲突的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_SYSDMA1_DMA_C0_CYCLE0</td><td>47</td><td>DMA控制器1上Channel 0最近一次数据传输耗费的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_SYSDMA1_DMA_C0_CYCLE1</td><td>48</td><td>DMA控制器1上Channel 0所有数据传输耗费的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_SYSDMA1_DMA_C0_BYTE</td><td>49</td><td>DMA控制器1上Channel 0传输的数据量，单位为字节。</td></tr><tr><td>STC_PTI_EVENT_ID_SYSDMA1_DMA_C1_CYCLE0</td><td>50</td><td>DMA控制器1上Channel 1最近一次数据传输耗费的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_SYSDMA1_DMA_C1_CYCLE1</td><td>51</td><td>DMA控制器1上Channel 1所有数据传输耗费的cycle数。</td></tr><tr><td>STC_PTI_EVENT_ID_SYSDMA1_DMA_C1_BYTE</td><td>52</td><td>DMA控制器1上Channel 1传输的数据量，单位为字节。</td></tr><tr><td>STC_PTI_EVENT_ID_MAX</td><td>53</td><td>stcPtiEventID_t枚举定义的边界值。</td></tr></tbody></table></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/希姆计算开发者资源/C++ API.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/希姆计算介绍"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">希姆计算</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/希姆计算开发者资源/HPE错误信息分类标识"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">HPE错误信息分类标识</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#hpe主机端运行时api" class="table-of-contents__link toc-highlight">HPE主机端运行时API</a><ul><li><a href="#调用要求" class="table-of-contents__link toc-highlight">调用要求</a></li><li><a href="#调用限制" class="table-of-contents__link toc-highlight">调用限制</a></li><li><a href="#接口说明" class="table-of-contents__link toc-highlight">接口说明</a></li></ul></li><li><a href="#hpe设备端运行时api" class="table-of-contents__link toc-highlight">HPE设备端运行时API</a><ul><li><a href="#调用要求-1" class="table-of-contents__link toc-highlight">调用要求</a></li><li><a href="#接口说明-1" class="table-of-contents__link toc-highlight">接口说明</a></li><li><a href="#数据类型-1" class="table-of-contents__link toc-highlight">数据类型</a></li><li><a href="#变量" class="table-of-contents__link toc-highlight">变量</a></li></ul></li><li><a href="#stcpti性能数据采集api" class="table-of-contents__link toc-highlight">STCPTI性能数据采集API</a><ul><li><a href="#调用要求-2" class="table-of-contents__link toc-highlight">调用要求</a></li><li><a href="#接口说明-2" class="table-of-contents__link toc-highlight">接口说明</a></li><li><a href="#数据类型-2" class="table-of-contents__link toc-highlight">数据类型</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/希姆计算术语表">希姆计算术语</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://x.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">X<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>